{
  "hash": "bd979897660c15f3be09cc66e0a69a1e",
  "result": {
    "engine": "knitr",
    "markdown": "# R Programming Fundamentals {#sec-r-programming}\n\n\n\n::: {.callout-note title=\"Learning Objectives\"}\nAfter completing this chapter, you will be able to:\n\n- Explain why R is well-suited for scientific computing\n- Understand R's object-oriented nature and examine objects with `class()`, `typeof()`, and `str()`\n- Use RStudio as an integrated development environment\n- Perform basic arithmetic and variable assignment in R\n- Work with vectors and understand vectorized operations\n- Use logical operators and handle floating-point comparisons correctly\n- Create and manipulate data frames, lists, and matrices\n- Use built-in functions and access help documentation including vignettes\n- Install packages and resolve namespace conflicts\n- Create basic visualizations\n- Read and write data files\n- Clean up your R environment and graphics devices\n:::\n\n## Why R for Scientific Computing? {#sec-why-r}\n\nR is a programming language designed specifically for statistical computing and graphics [@rproject2024]. It is an offshoot of a language called **S**, developed in 1976 at Bell Laboratories by John Chambers and colleagues. R was created in 1991 by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand (hence the name \"R\"), and has since become one of the most widely used tools in data science, statistics, and bioinformatics.\n\nAs an **interpreted language**, R code is translated to machine language by the R interpreter each time it runs, as opposed to being compiled beforehand. This makes R highly interactive and excellent for exploratory data analysis.\n\nR offers several advantages for researchers:\n\n**Statistical Power.** R was built by statisticians for statistics. It includes comprehensive implementations of classical and modern statistical methods.\n\n**Graphics Excellence.** R produces publication-quality graphics with fine-grained control over every aspect of visualization.\n\n**Package Ecosystem.** Over 20,000 packages extend R's capabilities for virtually every analytical need, from genomics to machine learning.\n\n**Reproducibility.** R scripts document your analysis completely. Combined with Quarto (which produced this book!), you can create reproducible documents that integrate code, results, and narrative.\n\n**Active Community.** A large, welcoming community provides abundant resources, tutorials, and support.\n\n**Cost.** R is free and open-source, removing financial barriers to sophisticated analysis.\n\n## RStudio: Your R Environment {#sec-rstudio}\n\nWhile R can run from the command line, most users work in **RStudio**, an integrated development environment (IDE) that makes R more accessible and productive.\n\n### The RStudio Interface\n\nRStudio organizes your workspace into four panes:\n\n**Source (top-left).** Where you write and edit scripts. Code here isn't executed until you explicitly run it.\n\n**Console (bottom-left).** The interactive R session. Commands typed here execute immediately. Output appears here.\n\n**Environment/History (top-right).** Shows variables you've created (Environment tab) and commands you've run (History tab).\n\n**Files/Plots/Help (bottom-right).** File browser, plot viewer, and help documentation.\n\n![The RStudio interface showing all four panes: Source (top-left) with R code, Console (bottom-left) showing command output, Environment/Workspace (top-right) displaying variables and data, and Plots (bottom-right) showing a visualization.](images/RStudio_Screenshot.png){#fig-rstudio-interface width=\"100%\"}\n\n::: {.callout-tip}\nLearn keyboard shortcuts! `Ctrl+Enter` (Windows/Linux) or `Cmd+Enter` (Mac) runs the current line or selection. `Ctrl+Shift+S` runs the entire script.\n:::\n\n### RStudio Projects\n\nRStudio Projects organize your work with self-contained directories:\n\n1. Go to File → New Project\n2. Choose New Directory → New Project\n3. Name your project and select a location\n4. RStudio creates a `.Rproj` file\n\nProjects set your working directory automatically and keep related files together—essential for reproducible research.\n\n## Understanding R: Everything is an Object {#sec-r-objects}\n\nBefore diving into R syntax, it helps to understand R's fundamental design philosophy: **everything in R is an object**. This object-oriented approach means that every piece of data you work with—numbers, text, datasets, even functions themselves—is stored as an object with specific properties.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Numbers are objects\nx <- 42\nclass(x)\n#> [1] \"numeric\"\ntypeof(x)\n#> [1] \"double\"\n\n# Text strings are objects\nname <- \"Gene Expression\"\nclass(name)\n#> [1] \"character\"\ntypeof(name)\n#> [1] \"character\"\n\n# Even functions are objects!\nclass(mean)\n#> [1] \"function\"\ntypeof(mean)\n#> [1] \"closure\"\n\n# And data frames are objects\ndf <- data.frame(a = 1:3, b = c(\"x\", \"y\", \"z\"))\nclass(df)\n#> [1] \"data.frame\"\ntypeof(df)\n#> [1] \"list\"\n```\n:::\n\n\nEvery object has:\n\n- **A class**: Determines how the object behaves with functions (what `class()` returns)\n- **A type**: The underlying storage mode (what `typeof()` returns)\n- **Attributes**: Optional metadata like names, dimensions, or custom properties\n\nThe `str()` function provides a compact display of an object's structure:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Examine structure of different objects\nstr(x)\n#>  num 42\nstr(name)\n#>  chr \"Gene Expression\"\nstr(df)\n#> 'data.frame':\t3 obs. of  2 variables:\n#>  $ a: int  1 2 3\n#>  $ b: chr  \"x\" \"y\" \"z\"\n```\n:::\n\n\nUnderstanding this object-oriented nature helps you:\n\n1. **Debug errors**: When functions fail, check what class of object you're passing\n2. **Use generic functions**: Functions like `print()`, `summary()`, and `plot()` behave differently based on object class\n3. **Extend R**: You can create custom classes with specialized behaviors\n\n## R Basics: Arithmetic and Variables {#sec-r-basics}\n\n### R as a Calculator\n\nThe simplest use of R is arithmetic:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Basic operations\n4 * 4\n#> [1] 16\n\n# Order of operations applies\n(4 + 3 * 2^2)\n#> [1] 16\n\n# More complex expressions\nsqrt(144) + log(100)\n#> [1] 16.60517\n\n# Integer division and modulo\n17 %/% 5    # Integer division: how many times 5 goes into 17\n#> [1] 3\n17 %% 5     # Modulo: remainder after division\n#> [1] 2\n```\n:::\n\n\nR follows standard mathematical order of operations (PEMDAS). The modulo operator (`%%`) is particularly useful for tasks like determining if a number is even or odd, cycling through indices, or extracting digits from numbers:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Check if numbers are even (remainder 0 when divided by 2)\nnumbers <- 1:10\nnumbers %% 2 == 0\n#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n# Extract the last digit of a number\n12345 %% 10\n#> [1] 5\n```\n:::\n\n\n### Creating Variables\n\nVariables store values for later use. In R, the assignment operator is `<-`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Assign values to variables\nx <- 2\ny <- 5\n\n# Use variables in calculations\nx * 3\n#> [1] 6\ny + x\n#> [1] 7\n\n# Store results in new variables\nz <- x * y\nz\n#> [1] 10\n```\n:::\n\n\n::: {.callout-note}\nYou can also use `=` for assignment in R, but `<-` is the traditional and preferred style. It makes assignment visually distinct from function arguments, which use `=`.\n:::\n\n### Variable Naming Rules\n\n- Names must start with a letter\n- Can contain letters, numbers, periods, and underscores\n- R is case-sensitive: `Gene` and `gene` are different variables\n- Use descriptive names: `sample_count` is better than `sc`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Valid names\ngene_count <- 100\nSample.1 <- \"control\"\nmyData2 <- 42\n\n# Invalid (would cause errors)\n# 2samples <- 5      # Can't start with number\n# my-data <- 10      # Hyphens not allowed\n```\n:::\n\n\n### Reserved Words\n\nR has **reserved words** that cannot be used as variable names because they have special meaning in the language:\n\n| Reserved Words | Description |\n|:---------------|:------------|\n| `if`, `else` | Conditional statements |\n| `for`, `while`, `repeat` | Loop constructs |\n| `function` | Function definition |\n| `in` | Used in for loops |\n| `next`, `break` | Loop control |\n| `TRUE`, `FALSE` | Logical constants |\n| `NULL` | Null object |\n| `Inf`, `NaN`, `NA` | Special numeric values |\n\n: R reserved words {#tbl-reserved-words}\n\nR also has **semi-reserved words**—names of built-in constants and functions that you *can* overwrite but generally shouldn't:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# These work but are dangerous:\nT <- 5       # Overwrites TRUE abbreviation\nF <- 10      # Overwrites FALSE abbreviation\nc <- \"text\"  # Shadows the c() function\nmean <- 42   # Shadows the mean() function\n\n# If you accidentally overwrite something, use rm() to remove it\nrm(c)        # Removes your 'c' variable, restoring access to c()\n```\n:::\n\n\n::: {.callout-warning}\nAvoid using `T` and `F` as variable names—they are common abbreviations for `TRUE` and `FALSE`. Similarly, never name variables `c`, `t`, `mean`, `sum`, or other common function names.\n:::\n\n## Key R Terminology {#sec-r-terminology}\n\nBefore diving deeper into R, let's establish some fundamental terminology that you'll encounter throughout your R programming journey:\n\n![Core R concepts: Objects, Vectors, Functions, Parameters, and Arguments are the building blocks of R programming.](images/R_definitions_Logan.001.jpeg){#fig-r-terminology width=\"90%\"}\n\nUnderstanding R's operators is equally important. The table below shows the main operators you'll use, listed in order of precedence (operations higher in the table are evaluated first):\n\n![R operators reference: This table shows common R operators for indexing, arithmetic, comparison, logical operations, and assignment.](images/R_definitions_Logan.002.jpeg){#fig-r-operators width=\"70%\"}\n\n::: {.callout-tip}\nNote that R uses `<-` for assignment (right to left), while `=` is typically used for argument assignment within function calls. Both work for variable assignment, but `<-` is the conventional R style.\n:::\n\n## Vectors: R's Fundamental Data Structure {#sec-vectors}\n\nR thinks in terms of **vectors**—ordered collections of values of the same type. Even a single number is a vector of length 1.\n\n### Creating Vectors\n\nThe `c()` function (for \"combine\" or \"concatenate\") creates vectors:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Numeric vector\nmeasurements <- c(2, 3, 4, 2, 1, 2, 4, 5, 10, 8, 9)\nmeasurements\n#>  [1]  2  3  4  2  1  2  4  5 10  8  9\n\n# Character vector\nsamples <- c(\"control\", \"treatment_A\", \"treatment_B\")\nsamples\n#> [1] \"control\"     \"treatment_A\" \"treatment_B\"\n\n# Logical vector\npassed <- c(TRUE, FALSE, TRUE, TRUE, FALSE)\npassed\n#> [1]  TRUE FALSE  TRUE  TRUE FALSE\n```\n:::\n\n\n### Sequence Generation\n\nFor regular sequences, use shortcuts:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Integer sequence\n1:10\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Sequence with step\nseq(0, 10, by = 0.5)\n#>  [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0\n#> [16]  7.5  8.0  8.5  9.0  9.5 10.0\n\n# Specified length\nseq(0, 1, length.out = 5)\n#> [1] 0.00 0.25 0.50 0.75 1.00\n\n# Repeated values\nrep(\"A\", 5)\n#> [1] \"A\" \"A\" \"A\" \"A\" \"A\"\nrep(c(1, 2), times = 3)\n#> [1] 1 2 1 2 1 2\nrep(c(1, 2), each = 3)\n#> [1] 1 1 1 2 2 2\n```\n:::\n\n\n### Sorting Vectors\n\nThe `sort()` function returns a sorted vector:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Sort in ascending order (default)\nx <- c(5, 2, 8, 1, 9, 3)\nsort(x)\n#> [1] 1 2 3 5 8 9\n\n# Sort in descending order\nsort(x, decreasing = TRUE)\n#> [1] 9 8 5 3 2 1\n\n# Sorting character vectors (alphabetical)\ngenes <- c(\"BRCA1\", \"TP53\", \"EGFR\", \"KRAS\")\nsort(genes)\n#> [1] \"BRCA1\" \"EGFR\"  \"KRAS\"  \"TP53\"\n```\n:::\n\n\nTo get the indices that would sort a vector (useful for reordering related data), use `order()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(5, 2, 8, 1, 9, 3)\norder(x)  # Indices: 4th element is smallest, 2nd is next, etc.\n#> [1] 4 2 6 1 3 5\n\n# Use order() to sort one vector by another\nnames <- c(\"Sample_A\", \"Sample_B\", \"Sample_C\")\nvalues <- c(30, 10, 20)\nnames[order(values)]  # Names sorted by values\n#> [1] \"Sample_B\" \"Sample_C\" \"Sample_A\"\n```\n:::\n\n\n### Vectorized Operations\n\nR's power comes from **vectorized operations**—operations that apply to entire vectors at once:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(2, 3, 4, 2, 1, 2, 4, 5, 10, 8, 9)\n\n# Operations apply to each element\nx * 2\n#>  [1]  4  6  8  4  2  4  8 10 20 16 18\nx^2\n#>  [1]   4   9  16   4   1   4  16  25 100  64  81\nlog(x)\n#>  [1] 0.6931472 1.0986123 1.3862944 0.6931472 0.0000000 0.6931472 1.3862944\n#>  [8] 1.6094379 2.3025851 2.0794415 2.1972246\nsqrt(x)\n#>  [1] 1.414214 1.732051 2.000000 1.414214 1.000000 1.414214 2.000000 2.236068\n#>  [9] 3.162278 2.828427 3.000000\n\n# Operations between vectors (element-wise)\ny <- 1:11\nx + y\n#>  [1]  3  5  7  6  6  8 11 13 19 18 20\nx * y\n#>  [1]  2  6 12  8  5 12 28 40 90 80 99\n```\n:::\n\n\nThis is much faster and cleaner than writing loops!\n\n### Vector Indexing\n\nAccess specific elements using square brackets:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmeasurements <- c(2, 3, 4, 2, 1, 2, 4, 5, 10, 8, 9)\n\n# Single element (1-indexed!)\nmeasurements[1]\n#> [1] 2\nmeasurements[5]\n#> [1] 1\n\n# Multiple elements\nmeasurements[c(1, 3, 5)]\n#> [1] 2 4 1\n\n# Range\nmeasurements[2:5]\n#> [1] 3 4 2 1\n\n# Negative indices exclude\nmeasurements[-1]          # All but first\n#>  [1]  3  4  2  1  2  4  5 10  8  9\nmeasurements[-(1:3)]      # All but first three\n#> [1]  2  1  2  4  5 10  8  9\n\n# Logical indexing\nmeasurements[measurements > 5]\n#> [1] 10  8  9\n```\n:::\n\n\n::: {.callout-important}\nR uses 1-based indexing! The first element is `[1]`, not `[0]` as in Python and most other languages.\n:::\n\n## Data Types in R {#sec-data-types}\n\nR has several fundamental data types:\n\n| Type | Description | Example |\n|:-----|:------------|:--------|\n| `numeric` | Real numbers (default) | `3.14`, `42` |\n| `integer` | Whole numbers | `1L`, `100L` |\n| `character` | Text strings | `\"hello\"`, `\"gene1\"` |\n| `logical` | Boolean values | `TRUE`, `FALSE` |\n| `factor` | Categorical variables | Treatment levels |\n\n: R data types {#tbl-data-types}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Check types with class()\nclass(3.14)\n#> [1] \"numeric\"\nclass(\"hello\")\n#> [1] \"character\"\nclass(TRUE)\n#> [1] \"logical\"\n\n# Type coercion\nas.numeric(\"42\")\n#> [1] 42\nas.character(123)\n#> [1] \"123\"\nas.logical(0)    # FALSE\n#> [1] FALSE\nas.logical(1)    # TRUE\n#> [1] TRUE\n```\n:::\n\n\n### Factors\n\n**Factors** are special vectors for representing categorical data with a fixed set of possible values called **levels**. They're essential for statistical modeling and data analysis in R:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create a factor from a character vector\ntreatment <- c(\"control\", \"drug_A\", \"drug_A\", \"control\", \"drug_B\", \"drug_B\")\ntreatment_factor <- as.factor(treatment)\ntreatment_factor\n#> [1] control drug_A  drug_A  control drug_B  drug_B \n#> Levels: control drug_A drug_B\n\n# Check the levels\nlevels(treatment_factor)\n#> [1] \"control\" \"drug_A\"  \"drug_B\"\n```\n:::\n\n\n::: {.callout-note}\nFactor levels are stored **alphabetically** by default, regardless of the order they appear in your data. This affects how results are displayed and can impact statistical analyses (e.g., the reference level in regression models).\n:::\n\nTo specify a custom level order, use the `levels` argument:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Custom level order\ntreatment_ordered <- factor(treatment,\n                            levels = c(\"control\", \"drug_A\", \"drug_B\"))\nlevels(treatment_ordered)\n#> [1] \"control\" \"drug_A\"  \"drug_B\"\n\n# This matters for plotting and statistical models\n# where \"control\" should be the reference level\n```\n:::\n\n\nFactors are memory-efficient because they store unique levels once and use integer indices to reference them. Use `str()` to see this internal representation:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(treatment_factor)\n#>  Factor w/ 3 levels \"control\",\"drug_A\",..: 1 2 2 1 3 3\n```\n:::\n\n\n### Special Values\n\nR has special values for missing data and undefined results:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Missing value\nNA\n#> [1] NA\n\n# Not a number (undefined)\n0/0\n#> [1] NaN\nlog(-1)\n#> [1] NaN\n\n# Infinity\n1/0\n#> [1] Inf\n-1/0\n#> [1] -Inf\n```\n:::\n\n\nHandling `NA` values is a common task in data analysis.\n\n### Logical Operators and Comparisons\n\nR provides a rich set of operators for logical comparisons and Boolean operations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Comparison operators\n5 > 3     # Greater than\n#> [1] TRUE\n5 < 3     # Less than\n#> [1] FALSE\n5 >= 5    # Greater than or equal\n#> [1] TRUE\n5 <= 5    # Less than or equal\n#> [1] TRUE\n5 == 5    # Equal (note: two equals signs!)\n#> [1] TRUE\n5 != 3    # Not equal\n#> [1] TRUE\n\n# Logical operators\nTRUE & FALSE   # AND\n#> [1] FALSE\nTRUE | FALSE   # OR\n#> [1] TRUE\n!TRUE          # NOT\n#> [1] FALSE\n\n# Vectorized logical operations\nx <- c(1, 5, 10, 15, 20)\nx > 5 & x < 18   # Both conditions must be true\n#> [1] FALSE FALSE  TRUE  TRUE FALSE\nx < 5 | x > 15   # Either condition can be true\n#> [1]  TRUE FALSE FALSE FALSE  TRUE\n```\n:::\n\n\nThe `%in%` operator is particularly useful for checking membership in a set:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Check if values are in a set\ngenes <- c(\"BRCA1\", \"TP53\", \"EGFR\", \"KRAS\")\ntarget_genes <- c(\"TP53\", \"EGFR\")\n\ngenes %in% target_genes\n#> [1] FALSE  TRUE  TRUE FALSE\n\n# Useful for subsetting\ngenes[genes %in% target_genes]\n#> [1] \"TP53\" \"EGFR\"\n```\n:::\n\n\n### Finding Indices with `which()`\n\nThe `which()` function returns the indices where a logical condition is TRUE—useful when you need positions rather than values:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(10, 5, 20, 15, 8, 25)\n\n# Find indices where condition is TRUE\nwhich(x > 12)\n#> [1] 3 4 6\n\n# Get the values at those positions\nx[which(x > 12)]\n#> [1] 20 15 25\n\n# Find the index of the maximum value\nwhich.max(x)\n#> [1] 6\n\n# Find the index of the minimum value\nwhich.min(x)\n#> [1] 2\n\n# Find indices of specific values\nwhich(x == 15)\n#> [1] 4\n\n# Practical example: find which samples exceed a threshold\nexpression_levels <- c(2.5, 8.1, 4.2, 12.3, 6.7, 15.2)\nhigh_expression <- which(expression_levels > 10)\nhigh_expression  # Indices 4 and 6\n#> [1] 4 6\n```\n:::\n\n\n::: {.callout-tip}\nWhile `which()` is useful, you often don't need it—logical vectors work directly for subsetting:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# These are equivalent:\nx[which(x > 12)]\n#> [1] 20 15 25\nx[x > 12]\n#> [1] 20 15 25\n```\n:::\n\nUse `which()` when you specifically need the index positions (e.g., to report which samples, to use in loops, or for `which.max()`/`which.min()`).\n:::\n\n::: {.callout-important title=\"Operator Precedence\"}\nR evaluates operators in a specific order. From highest to lowest precedence:\n\n1. `^` (exponentiation)\n2. `-` (unary minus, for negation)\n3. `:` (sequence)\n4. `%any%` (special operators like `%%`, `%/%`, `%in%`)\n5. `*`, `/` (multiplication, division)\n6. `+`, `-` (addition, subtraction)\n7. `<`, `>`, `<=`, `>=`, `==`, `!=` (comparisons)\n8. `!` (logical NOT)\n9. `&`, `&&` (logical AND)\n10. `|`, `||` (logical OR)\n11. `<-`, `=` (assignment)\n\nUse parentheses to make your intentions clear and avoid unexpected results.\n:::\n\n### Floating-Point Precision\n\nA common source of confusion involves floating-point arithmetic. Computers represent decimal numbers with limited precision, which can lead to unexpected results:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# This seems wrong, but is due to floating-point representation\n0.1 + 0.2 == 0.3\n#> [1] FALSE\n\n# See the actual values\nprint(0.1 + 0.2, digits = 20)\n#> [1] 0.30000000000000004441\nprint(0.3, digits = 20)\n#> [1] 0.2999999999999999889\n```\n:::\n\n\nInstead of using `==` for floating-point comparisons, use `all.equal()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Safe comparison for floating-point numbers\nall.equal(0.1 + 0.2, 0.3)\n#> [1] TRUE\n\n# Returns TRUE if values are nearly equal (within tolerance)\nisTRUE(all.equal(0.1 + 0.2, 0.3))\n#> [1] TRUE\n\n# You can also specify a tolerance\nall.equal(1.0, 1.0001, tolerance = 0.001)\n#> [1] TRUE\n```\n:::\n\n\n::: {.callout-warning}\nAlways use `all.equal()` or check if the difference is within an acceptable tolerance when comparing floating-point numbers. Never rely on `==` for exact equality of decimal calculations.\n:::\n\n### Using `dplyr::near()` for Comparisons\n\nThe tidyverse provides `dplyr::near()` as a convenient alternative for checking near-equality, especially when working with data frames:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# near() returns TRUE for values within a small tolerance\nnear(0.1 + 0.2, 0.3)\n#> [1] TRUE\n\n# Works well in filter() and mutate()\ndf <- tibble(x = c(0.1 + 0.2, 0.5, 0.3))\ndf |> filter(near(x, 0.3))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   x|\n|---:|\n| 0.3|\n| 0.3|\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# You can specify a custom tolerance\nnear(1.0, 1.001, tol = 0.01)\n#> [1] TRUE\n```\n:::\n\n\nUse `near()` when filtering or comparing numeric columns in data frames, and `all.equal()` when you need detailed comparison information.\n\n## Functions {#sec-r-functions}\n\nFunctions perform operations on inputs and return outputs. R has thousands of built-in functions.\n\n### Using Functions\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\n# Basic statistical functions\nmean(x)\n#> [1] 5.5\nmedian(x)\n#> [1] 5.5\nsd(x)        # Standard deviation\n#> [1] 3.02765\nvar(x)       # Variance\n#> [1] 9.166667\nsum(x)\n#> [1] 55\nlength(x)\n#> [1] 10\nmin(x)\n#> [1] 1\nmax(x)\n#> [1] 10\nrange(x)     # Returns min and max\n#> [1]  1 10\n```\n:::\n\n\n### Function Arguments\n\nFunctions take arguments that modify their behavior:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Round to 2 decimal places\nround(3.14159, digits = 2)\n#> [1] 3.14\n\n# Sample with replacement\nsample(1:10, size = 5, replace = TRUE)\n#> [1] 9 4 4 2 7\n\n# Mean with NA handling\nvalues <- c(1, 2, NA, 4, 5)\nmean(values)              # Returns NA\n#> [1] NA\nmean(values, na.rm = TRUE)  # Removes NA first\n#> [1] 3\n```\n:::\n\n\n#### Argument Order and Naming\n\nR functions expect arguments in a specific order. When you don't name arguments, R matches them by position:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# These are equivalent - arguments matched by position\nset.seed(42)\nx1 <- rnorm(5, 0, 10)  # n, mean, sd\nx1\n#> [1] 13.709584 -5.646982  3.631284  6.328626  4.042683\n\n# Named arguments can be in any order\nset.seed(42)\nx2 <- rnorm(sd = 10, n = 5, mean = 0)\nx2\n#> [1] 13.709584 -5.646982  3.631284  6.328626  4.042683\n```\n:::\n\n\n::: {.callout-warning}\nRelying on position order can lead to subtle bugs. If you accidentally swap arguments, you may get unexpected results without any error message:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Oops! We meant 1000 samples with mean=0 and sd=10\n# But we got 10 samples with mean=1000 and sd=0\nwrong <- rnorm(10, 1000, 0)\nwrong  # All identical values!\n#>  [1] 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000\n```\n:::\n\n\nWhen in doubt, name your arguments explicitly for clarity and safety.\n:::\n\n### Nesting Functions\n\nOne powerful feature of R is the ability to **nest** function calls—using the output of one function as the input to another without creating intermediate variables:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Without nesting: create intermediate objects\nz <- c(10, 20, 30)\nresult1 <- mean(z)\nresult1\n#> [1] 20\n\n# With nesting: more concise\nresult2 <- mean(c(10, 20, 30))\nresult2\n#> [1] 20\n\n# More complex nesting\n# Calculate the mean of the square roots of 1 through 10\nmean(sqrt(1:10))\n#> [1] 2.246828\n\n# Nested functions are evaluated from inside out\nround(mean(sqrt(c(4, 9, 16, 25))), digits = 2)\n#> [1] 3.5\n```\n:::\n\n\nNesting makes code more compact, but deeply nested expressions can become hard to read. As a rule of thumb, if you find yourself nesting more than 2-3 functions, consider breaking the expression into steps or using the pipe operator (covered in the tidyverse chapter).\n\n### Getting Help\n\nR has excellent built-in documentation:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Get help on a function\n?mean\nhelp(mean)\n\n# Search help\nhelp.search(\"correlation\")\n??correlation\n\n# See function arguments\nargs(mean)\n\n# See examples\nexample(mean)\n\n# Find functions containing a string in their name\napropos(\"mean\")  # Returns: \"colMeans\", \"mean\", \"mean.Date\", etc.\n\n# Find functions by partial name matching\napropos(\"cor\")   # Returns all functions containing \"cor\"\n```\n:::\n\n\n#### Vignettes and Demos\n\nBeyond function-level help, packages often include **vignettes**—comprehensive tutorials that demonstrate how to use the package:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# List all available vignettes\nvignette()\n\n# List vignettes for a specific package\nvignette(package = \"dplyr\")\n\n# Open a specific vignette\nvignette(\"dplyr\")\n\n# Browse vignettes in your browser\nbrowseVignettes(\"ggplot2\")\n```\n:::\n\n\nSome packages also include **demos**—interactive demonstrations of functionality:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# List all available demos\ndemo()\n\n# Run a specific demo\ndemo(graphics)    # Base R graphics demonstration\n```\n:::\n\n\n::: {.callout-tip}\nVignettes are often the best place to start when learning a new package. They provide context and workflows that function documentation alone cannot convey.\n:::\n\nThe help page structure:\n\n- **Description**: What the function does\n- **Usage**: Function syntax\n- **Arguments**: What inputs it accepts\n- **Value**: What it returns\n- **Examples**: Working code examples\n\n## Installing and Loading Packages {#sec-packages}\n\nBase R includes dozens of useful functions, but as you become a more advanced R user, you'll need functions for specialized analyses. Fortunately, thousands of additional functions are distributed in the form of R **packages**.\n\n### Installing Packages\n\nPackages from the Comprehensive R Archive Network (CRAN) are easy to install:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Install a package from CRAN\ninstall.packages(\"dplyr\")\n\n# Install multiple packages at once\ninstall.packages(c(\"ggplot2\", \"readr\", \"tidyr\"))\n```\n:::\n\n\n::: {.callout-note}\nPackage names are case-sensitive and must be in quotation marks when installing. You only need to install a package once on your system.\n:::\n\n### Loading Packages\n\nTo use functions from an installed package, you must load it into your current session:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load a package\nlibrary(dplyr)\n\n# Check if a package is installed\ninstalled.packages(\"dplyr\")\n```\n:::\n\n\nUnlike installation, you need to call `library()` every time you start a new R session. Note that you don't need quotation marks with `library()`.\n\n::: {.callout-tip}\nIt's good practice to load all required packages at the beginning of your script. This makes dependencies clear and helps others reproduce your work.\n:::\n\n### Namespace Conflicts\n\nWhen you load multiple packages, function names can collide. The most recently loaded package \"wins,\" masking functions from earlier packages:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Loading dplyr after another package\nlibrary(MASS)\nlibrary(dplyr)\n# Warning: The following object is masked from 'package:MASS': select\n```\n:::\n\n\nWhen conflicts occur, you have several options:\n\n**1. Use the package prefix (recommended)**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Explicitly specify which package's function to use\ndplyr::select(data, column1, column2)\nMASS::select(object)\n\n# This works even without loading the package\nstats::filter(x, method = \"convolution\")\n```\n:::\n\n\n**2. Control loading order**\n\nLoad packages with conflicting names in the order that gives you the default behavior you want.\n\n**3. Use the `conflicted` package**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Install and load conflicted\ninstall.packages(\"conflicted\")\nlibrary(conflicted)\n\n# Now conflicts cause errors instead of silent masking\n# You must explicitly choose which function to use:\nconflict_prefer(\"filter\", \"dplyr\")\nconflict_prefer(\"select\", \"dplyr\")\n```\n:::\n\n\n::: {.callout-warning}\nThe `filter()` and `lag()` functions from dplyr commonly conflict with base R's `stats::filter()` and `stats::lag()`. If your filtering code suddenly stops working, namespace conflicts are often the culprit.\n:::\n\n## Data Frames {#sec-data-frames}\n\n**Data frames** are R's workhorse for tabular data—think spreadsheets or database tables. Each column is a vector, and columns can have different types.\n\n### Creating Data Frames\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create vectors\nsample_id <- c(\"S1\", \"S2\", \"S3\", \"S4\", \"S5\")\ntreatment <- c(\"control\", \"drug_A\", \"drug_A\", \"drug_B\", \"drug_B\")\nconcentration <- c(0, 10, 20, 10, 20)\nresponse <- c(1.2, 3.4, 5.6, 2.8, 4.1)\n\n# Combine into data frame\nexperiment <- data.frame(\n  sample_id = sample_id,\n  treatment = treatment,\n  concentration = concentration,\n  response = response\n)\n\nexperiment\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sample_id |treatment | concentration| response|\n|:---------|:---------|-------------:|--------:|\n|S1        |control   |             0|      1.2|\n|S2        |drug_A    |            10|      3.4|\n|S3        |drug_A    |            20|      5.6|\n|S4        |drug_B    |            10|      2.8|\n|S5        |drug_B    |            20|      4.1|\n\n</div>\n:::\n:::\n\n\n### Examining Data Frames\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Structure\nstr(experiment)\n#> 'data.frame':\t5 obs. of  4 variables:\n#>  $ sample_id    : chr  \"S1\" \"S2\" \"S3\" \"S4\" ...\n#>  $ treatment    : chr  \"control\" \"drug_A\" \"drug_A\" \"drug_B\" ...\n#>  $ concentration: num  0 10 20 10 20\n#>  $ response     : num  1.2 3.4 5.6 2.8 4.1\n\n# Dimensions\ndim(experiment)\n#> [1] 5 4\nnrow(experiment)\n#> [1] 5\nncol(experiment)\n#> [1] 4\n\n# Preview\nhead(experiment, 3)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sample_id |treatment | concentration| response|\n|:---------|:---------|-------------:|--------:|\n|S1        |control   |             0|      1.2|\n|S2        |drug_A    |            10|      3.4|\n|S3        |drug_A    |            20|      5.6|\n\n</div>\n:::\n\n```{.r .cell-code}\ntail(experiment, 2)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   |sample_id |treatment | concentration| response|\n|:--|:---------|:---------|-------------:|--------:|\n|4  |S4        |drug_B    |            10|      2.8|\n|5  |S5        |drug_B    |            20|      4.1|\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# Summary statistics\nsummary(experiment)\n#>   sample_id          treatment         concentration    response   \n#>  Length:5           Length:5           Min.   : 0    Min.   :1.20  \n#>  Class :character   Class :character   1st Qu.:10    1st Qu.:2.80  \n#>  Mode  :character   Mode  :character   Median :10    Median :3.40  \n#>                                        Mean   :12    Mean   :3.42  \n#>                                        3rd Qu.:20    3rd Qu.:4.10  \n#>                                        Max.   :20    Max.   :5.60\n\n# Column names\nnames(experiment)\n#> [1] \"sample_id\"     \"treatment\"     \"concentration\" \"response\"\ncolnames(experiment)\n#> [1] \"sample_id\"     \"treatment\"     \"concentration\" \"response\"\n```\n:::\n\n\nIn RStudio, you can also use `View()` to open a spreadsheet-like viewer for interactive exploration:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Opens data in a viewer pane (RStudio only)\nView(experiment)\n```\n:::\n\n\n::: {.callout-tip}\n`View()` is useful for quick inspection, but avoid using it in scripts meant for non-interactive execution. For large datasets, `View()` can be slow—use `head()` instead.\n:::\n\n### Accessing Data Frame Elements\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Single column (returns vector)\nexperiment$response\n#> [1] 1.2 3.4 5.6 2.8 4.1\nexperiment[[\"response\"]]\n#> [1] 1.2 3.4 5.6 2.8 4.1\nexperiment[, \"response\"]\n#> [1] 1.2 3.4 5.6 2.8 4.1\n\n# Multiple columns\nexperiment[, c(\"sample_id\", \"response\")]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sample_id | response|\n|:---------|--------:|\n|S1        |      1.2|\n|S2        |      3.4|\n|S3        |      5.6|\n|S4        |      2.8|\n|S5        |      4.1|\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# Rows by index\nexperiment[1, ]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sample_id |treatment | concentration| response|\n|:---------|:---------|-------------:|--------:|\n|S1        |control   |             0|      1.2|\n\n</div>\n:::\n\n```{.r .cell-code}\nexperiment[1:3, ]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sample_id |treatment | concentration| response|\n|:---------|:---------|-------------:|--------:|\n|S1        |control   |             0|      1.2|\n|S2        |drug_A    |            10|      3.4|\n|S3        |drug_A    |            20|      5.6|\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# Combination\nexperiment[1:3, c(\"treatment\", \"response\")]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|treatment | response|\n|:---------|--------:|\n|control   |      1.2|\n|drug_A    |      3.4|\n|drug_A    |      5.6|\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# Conditional selection\nexperiment[experiment$treatment == \"drug_A\", ]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   |sample_id |treatment | concentration| response|\n|:--|:---------|:---------|-------------:|--------:|\n|2  |S2        |drug_A    |            10|      3.4|\n|3  |S3        |drug_A    |            20|      5.6|\n\n</div>\n:::\n\n```{.r .cell-code}\nexperiment[experiment$response > 3, ]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|   |sample_id |treatment | concentration| response|\n|:--|:---------|:---------|-------------:|--------:|\n|2  |S2        |drug_A    |            10|      3.4|\n|3  |S3        |drug_A    |            20|      5.6|\n|5  |S5        |drug_B    |            20|      4.1|\n\n</div>\n:::\n:::\n\n\n### Adding and Modifying Columns\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Add a new column\nexperiment$replicate <- c(1, 1, 2, 1, 2)\n\n# Calculated column\nexperiment$log_response <- log(experiment$response)\n\nexperiment\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sample_id |treatment | concentration| response| replicate| log_response|\n|:---------|:---------|-------------:|--------:|---------:|------------:|\n|S1        |control   |             0|      1.2|         1|    0.1823216|\n|S2        |drug_A    |            10|      3.4|         1|    1.2237754|\n|S3        |drug_A    |            20|      5.6|         2|    1.7227666|\n|S4        |drug_B    |            10|      2.8|         1|    1.0296194|\n|S5        |drug_B    |            20|      4.1|         2|    1.4109870|\n\n</div>\n:::\n:::\n\n\n## Lists {#sec-lists}\n\n**Lists** are flexible containers that can hold objects of different types and lengths. Unlike vectors, which require all elements to be the same type, lists can contain a mix of vectors, data frames, or even other lists.\n\n### Creating Lists\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create individual vectors\nmeasurements <- c(10, 20, 30, 40, 50)\ncategories <- c(\"high\", \"medium\", \"low\")\nstatus <- factor(c(\"active\", \"inactive\"))\n\n# Combine into a list\nmy_list <- list(\n  values = measurements,\n  labels = categories,\n  status = status\n)\n\nmy_list\n#> $values\n#> [1] 10 20 30 40 50\n#> \n#> $labels\n#> [1] \"high\"   \"medium\" \"low\"   \n#> \n#> $status\n#> [1] active   inactive\n#> Levels: active inactive\n\n# Check the structure\nstr(my_list)\n#> List of 3\n#>  $ values: num [1:5] 10 20 30 40 50\n#>  $ labels: chr [1:3] \"high\" \"medium\" \"low\"\n#>  $ status: Factor w/ 2 levels \"active\",\"inactive\": 1 2\n```\n:::\n\n\n### Indexing Lists\n\nLists use double square brackets `[[]]` to access individual elements:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Access by position\nmy_list[[1]]\n#> [1] 10 20 30 40 50\n\n# Access by name\nmy_list[[\"labels\"]]\n#> [1] \"high\"   \"medium\" \"low\"\n\n# Access using $ notation\nmy_list$values\n#> [1] 10 20 30 40 50\n\n# Access element within a list component\nmy_list[[1]][3]  # Third element of first component\n#> [1] 30\n```\n:::\n\n\n::: {.callout-note}\nSingle brackets `[]` return a sublist, while double brackets `[[]]` extract the actual element. This distinction matters when working with list components.\n:::\n\n## Matrices {#sec-matrices}\n\n**Matrices** are two-dimensional arrays where all elements must be the same type. Unlike data frames, matrices don't have named columns by default and are optimized for mathematical operations.\n\n### Creating Matrices\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create a matrix from a vector\nmat <- matrix(1:12, nrow = 3, ncol = 4)\nmat\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    4    7   10\n#> [2,]    2    5    8   11\n#> [3,]    3    6    9   12\n\n# Create with row-wise filling\nmatrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    2    3    4\n#> [2,]    5    6    7    8\n#> [3,]    9   10   11   12\n\n# From vectors using cbind (column bind) or rbind (row bind)\ncol1 <- c(1, 2, 3)\ncol2 <- c(4, 5, 6)\ncbind(col1, col2)\n#>      col1 col2\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\n\nrbind(col1, col2)\n#>      [,1] [,2] [,3]\n#> col1    1    2    3\n#> col2    4    5    6\n```\n:::\n\n\n### Matrix Operations\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Dimensions\ndim(mat)\n#> [1] 3 4\nnrow(mat)\n#> [1] 3\nncol(mat)\n#> [1] 4\n\n# Transpose (swap rows and columns)\nt(mat)\n#>      [,1] [,2] [,3]\n#> [1,]    1    2    3\n#> [2,]    4    5    6\n#> [3,]    7    8    9\n#> [4,]   10   11   12\n\n# Indexing: [row, column]\nmat[1, 2]      # First row, second column\n#> [1] 4\nmat[1, ]       # Entire first row\n#> [1]  1  4  7 10\nmat[, 2]       # Entire second column\n#> [1] 4 5 6\nmat[1:2, 2:3]  # Submatrix\n#>      [,1] [,2]\n#> [1,]    4    7\n#> [2,]    5    8\n```\n:::\n\n\nMatrices are particularly useful for linear algebra operations and when you need efficient numerical computations.\n\n## Reading and Writing Data {#sec-reading-writing}\n\n### Reading Files\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# CSV files (comma-separated)\ndata <- read.csv(\"data.csv\")\n\n# Tab-separated files\ndata <- read.table(\"data.tsv\", header = TRUE, sep = \"\\t\")\n\n# Excel files (requires readxl package)\nlibrary(readxl)\ndata <- read_excel(\"data.xlsx\")\n\n# Specify options\ndata <- read.csv(\"data.csv\",\n                 header = TRUE,\n                 stringsAsFactors = FALSE,\n                 na.strings = c(\"\", \"NA\", \"N/A\"))\n```\n:::\n\n\n### Writing Files\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# CSV output\nwrite.csv(experiment, \"experiment_results.csv\", row.names = FALSE)\n\n# Tab-separated\nwrite.table(experiment, \"results.tsv\", \n            sep = \"\\t\", \n            quote = FALSE, \n            row.names = FALSE)\n```\n:::\n\n\n## Basic Visualization {#sec-basic-viz}\n\nR excels at creating graphics. Here's a quick introduction to base R plotting:\n\n### Scatter Plots\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:10\ny <- x^2\n\nplot(x, y, \n     main = \"Quadratic Relationship\",\n     xlab = \"X values\",\n     ylab = \"Y values\",\n     col = \"darkblue\",\n     pch = 16)  # Filled circles\n```\n\n::: {.cell-output-display}\n![Basic scatter plot showing quadratic relationship](07-r-programming_files/figure-html/fig-scatter-1.png){#fig-scatter fig-align='center' width=100%}\n:::\n:::\n\n\n### Histograms\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Generate random data\ndata <- rnorm(1000, mean = 50, sd = 10)\n\nhist(data,\n     main = \"Distribution of Values\",\n     xlab = \"Value\",\n     col = \"steelblue\",\n     breaks = 30)\n```\n\n::: {.cell-output-display}\n![Histogram of normally distributed data](07-r-programming_files/figure-html/fig-histogram-1.png){#fig-histogram fig-align='center' width=100%}\n:::\n:::\n\n\n### Box Plots\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create sample data\nset.seed(42)\ncontrol <- rnorm(30, mean = 10, sd = 2)\ntreatment <- rnorm(30, mean = 15, sd = 3)\n\nboxplot(control, treatment,\n        names = c(\"Control\", \"Treatment\"),\n        main = \"Treatment Effect\",\n        ylab = \"Response\",\n        col = c(\"lightblue\", \"lightcoral\"))\n```\n\n::: {.cell-output-display}\n![Box plot comparing treatment groups](07-r-programming_files/figure-html/fig-boxplot-1.png){#fig-boxplot fig-align='center' width=100%}\n:::\n:::\n\n\n### Multiple Plots\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create 2x2 layout\npar(mfrow = c(2, 2))\n\n# Four different plots\nplot(1:10, (1:10)^2, type = \"l\", main = \"Line Plot\")\nhist(rnorm(100), main = \"Histogram\")\nboxplot(rnorm(50), main = \"Box Plot\")\nbarplot(c(3, 5, 2, 7), names.arg = c(\"A\", \"B\", \"C\", \"D\"), main = \"Bar Plot\")\n\n# Reset to single plot\npar(mfrow = c(1, 1))\n```\n\n::: {.cell-output-display}\n![Multiple plots in a single figure](07-r-programming_files/figure-html/fig-multipanel-1.png){#fig-multipanel fig-align='center' width=100%}\n:::\n:::\n\n\n::: {.callout-tip}\nFor publication-quality graphics, explore the **ggplot2** package [@wickham2023r], which provides a powerful and consistent grammar of graphics.\n:::\n\n## The Split-Apply-Combine Approach {#sec-split-apply-combine}\n\nA common pattern in data analysis is to split data by groups, apply a function to each group, and combine the results. This **split-apply-combine** workflow appears repeatedly in scientific computing.\n\n### Using `tapply()` for Grouped Operations\n\nThe `tapply()` function applies a function to subsets of a vector, split by a factor:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Sample data\nvalues <- c(23, 45, 67, 34, 56, 78, 12, 89)\ngroups <- factor(c(\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\", \"C\"))\n\n# Mean by group\ntapply(values, groups, mean)\n#>    A    B    C \n#> 45.0 56.0 50.5\n\n# Standard deviation by group\ntapply(values, groups, sd)\n#>        A        B        C \n#> 22.00000 22.00000 54.44722\n\n# Custom summary: range\ntapply(values, groups, function(x) max(x) - min(x))\n#>  A  B  C \n#> 44 44 77\n```\n:::\n\n\n### Using `aggregate()` for Data Frames\n\nFor data frames, `aggregate()` summarizes multiple columns at once:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Using built-in iris data\nhead(iris)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| Sepal.Length| Sepal.Width| Petal.Length| Petal.Width|Species |\n|------------:|-----------:|------------:|-----------:|:-------|\n|          5.1|         3.5|          1.4|         0.2|setosa  |\n|          4.9|         3.0|          1.4|         0.2|setosa  |\n|          4.7|         3.2|          1.3|         0.2|setosa  |\n|          4.6|         3.1|          1.5|         0.2|setosa  |\n|          5.0|         3.6|          1.4|         0.2|setosa  |\n|          5.4|         3.9|          1.7|         0.4|setosa  |\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# Mean of all numeric columns by Species\naggregate(. ~ Species, data = iris, FUN = mean)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Species    | Sepal.Length| Sepal.Width| Petal.Length| Petal.Width|\n|:----------|------------:|-----------:|------------:|-----------:|\n|setosa     |        5.006|       3.428|        1.462|       0.246|\n|versicolor |        5.936|       2.770|        4.260|       1.326|\n|virginica  |        6.588|       2.974|        5.552|       2.026|\n\n</div>\n:::\n\n```{.r .cell-code}\n\n# Multiple statistics (result contains a matrix column)\nagg_result <- aggregate(Sepal.Length ~ Species, data = iris,\n                        FUN = function(x) c(mean = mean(x), sd = sd(x)))\n\n# Convert to a regular data frame for display\ndo.call(data.frame, agg_result)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Species    | Sepal.Length.mean| Sepal.Length.sd|\n|:----------|-----------------:|---------------:|\n|setosa     |             5.006|       0.3524897|\n|versicolor |             5.936|       0.5161711|\n|virginica  |             6.588|       0.6358796|\n\n</div>\n:::\n:::\n\n\n### The `apply()` Family\n\nR provides several related functions for different data structures:\n\n| Function | Input | Applies Over |\n|:---------|:------|:-------------|\n| `apply()` | Matrix/data frame | Rows or columns |\n| `lapply()` | List | Each element, returns list |\n| `sapply()` | List | Each element, returns vector |\n| `tapply()` | Vector + factor | Groups defined by factor |\n| `mapply()` | Multiple vectors | Corresponding elements |\n\n: The apply family of functions {#tbl-apply-family}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Apply to matrix columns\nmat <- matrix(1:12, nrow = 3)\napply(mat, 2, sum)  # Column sums (MARGIN = 2)\n#> [1]  6 15 24 33\napply(mat, 1, sum)  # Row sums (MARGIN = 1)\n#> [1] 22 26 30\n\n# Apply to each element of a list\nmy_list <- list(a = 1:5, b = 10:15, c = 100:110)\nlapply(my_list, mean)\n#> $a\n#> [1] 3\n#> \n#> $b\n#> [1] 12.5\n#> \n#> $c\n#> [1] 105\nsapply(my_list, mean)  # Simplified output\n#>     a     b     c \n#>   3.0  12.5 105.0\n```\n:::\n\n\n::: {.callout-tip}\nThe tidyverse packages (covered in the next chapter) provide more intuitive alternatives like `group_by()` and `summarize()` for this workflow.\n:::\n\n## Basic Programming Constructs {#sec-programming-constructs}\n\nAs you develop your R skills, you'll encounter situations requiring conditional logic and iteration.\n\n### Conditional Statements with `ifelse()`\n\nThe `ifelse()` function provides vectorized conditional logic:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Basic ifelse\nscores <- c(85, 72, 91, 68, 79)\nifelse(scores >= 80, \"Pass\", \"Fail\")\n#> [1] \"Pass\" \"Fail\" \"Pass\" \"Fail\" \"Fail\"\n\n# Nested conditions\ngrades <- ifelse(scores >= 90, \"A\",\n           ifelse(scores >= 80, \"B\",\n             ifelse(scores >= 70, \"C\", \"F\")))\ngrades\n#> [1] \"B\" \"C\" \"A\" \"F\" \"C\"\n\n# Useful for creating indicator variables\ntreatment <- c(\"control\", \"drug\", \"drug\", \"control\", \"drug\")\ncolors <- ifelse(treatment == \"drug\", \"red\", \"blue\")\n```\n:::\n\n\n### Type-Safe Conditionals with `if_else()`\n\nThe tidyverse provides `dplyr::if_else()`, which is stricter than base R's `ifelse()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nx <- c(-2, -1, 0, 1, 2)\n\n# if_else() requires matching types for true/false\nif_else(x > 0, \"positive\", \"non-positive\")\n#> [1] \"non-positive\" \"non-positive\" \"non-positive\" \"positive\"     \"positive\"\n\n# Handles NA explicitly with the 'missing' argument\ny <- c(1, NA, 3, NA, 5)\nif_else(y > 2, \"high\", \"low\", missing = \"unknown\")\n#> [1] \"low\"     \"unknown\" \"high\"    \"unknown\" \"high\"\n\n# Creates a simple absolute value implementation\nif_else(x < 0, -x, x)\n#> [1] 2 1 0 1 2\n```\n:::\n\n\n::: {.callout-tip}\nUse `dplyr::if_else()` over base `ifelse()` when:\n\n- You want type checking (prevents accidentally mixing numbers and strings)\n- You need explicit control over NA handling\n- You're already using tidyverse functions\n:::\n\n### For Loops\n\nWhile R is optimized for vectorized operations, loops are sometimes necessary:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Simple loop\nfor (i in 1:5) {\n  print(i^2)\n}\n#> [1] 1\n#> [1] 4\n#> [1] 9\n#> [1] 16\n#> [1] 25\n\n# Loop with pre-allocated output (recommended for efficiency)\nn <- 10\nresults <- numeric(n)  # Pre-allocate\nfor (i in 1:n) {\n  results[i] <- i * 2\n}\nresults\n#>  [1]  2  4  6  8 10 12 14 16 18 20\n```\n:::\n\n\n::: {.callout-warning}\nIn R, loops are often slower than vectorized alternatives. Before writing a loop, consider whether a vectorized function (`apply()`, `tapply()`, etc.) or built-in operation would work instead.\n:::\n\n### Writing Simple Functions\n\nYou can create your own functions for repeated tasks:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define a function\ncalculate_cv <- function(x) {\n  # Coefficient of variation: SD / mean * 100\n  cv <- sd(x) / mean(x) * 100\n  return(cv)\n}\n\n# Use the function\ndata <- c(10, 12, 11, 13, 9, 14)\ncalculate_cv(data)\n#> [1] 16.26808\n\n# Function with multiple arguments and default values\nsummarize_data <- function(x, digits = 2) {\n  result <- c(\n    mean = round(mean(x), digits),\n    sd = round(sd(x), digits),\n    n = length(x)\n  )\n  return(result)\n}\n\nsummarize_data(data)\n#>  mean    sd     n \n#> 11.50  1.87  6.00\nsummarize_data(data, digits = 3)\n#>   mean     sd      n \n#> 11.500  1.871  6.000\n```\n:::\n\n\n## Random Sampling and Simulation {#sec-random-sampling}\n\nR makes it easy to generate random data and run simulations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(123)\n\n# Random samples from distributions\nuniform_sample <- runif(100, min = 0, max = 1)\nnormal_sample <- rnorm(1000, mean = 0, sd = 1)\npoisson_sample <- rpois(100, lambda = 5)\n\n# Visualize normal distribution\nhist(normal_sample, \n     probability = TRUE,  # Density instead of counts\n     main = \"Sample vs. Theoretical Distribution\",\n     col = \"lightblue\")\n\n# Add theoretical curve\ncurve(dnorm(x, mean = 0, sd = 1), \n      add = TRUE, \n      col = \"red\", \n      lwd = 2)\n```\n\n::: {.cell-output-display}\n![Simulated data from a normal distribution with theoretical curve overlay](07-r-programming_files/figure-html/fig-simulation-1.png){#fig-simulation fig-align='center' width=100%}\n:::\n:::\n\n\n### Common Distribution Functions\n\nFor distribution `xxx` (e.g., `norm`, `unif`, `pois`, `binom`):\n\n- `rxxx()` — Random samples\n- `dxxx()` — Density/probability\n- `pxxx()` — Cumulative distribution function\n- `qxxx()` — Quantile function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Normal distribution\nrnorm(5)        # 5 random values\n#> [1]  0.9159921  0.8006224 -0.9365690 -1.4007874  0.1602775\ndnorm(0)        # Density at x=0\n#> [1] 0.3989423\npnorm(1.96)     # P(X ≤ 1.96)\n#> [1] 0.9750021\nqnorm(0.975)    # Value where P(X ≤ x) = 0.975\n#> [1] 1.959964\n```\n:::\n\n\n### Repeated Simulations with `replicate()`\n\nThe `replicate()` function repeats an expression multiple times and collects the results—perfect for simulations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Shuffle integers 1-10 five times\nset.seed(42)\nreplicate(5, sample(1:10, size = 10, replace = FALSE))\n#>       [,1] [,2] [,3] [,4] [,5]\n#>  [1,]    1    8    9    3    5\n#>  [2,]    5    7   10    1    4\n#>  [3,]   10    4    3    2    2\n#>  [4,]    8    1    4    6    8\n#>  [5,]    2    5    5   10    3\n#>  [6,]    4   10    6    8    1\n#>  [7,]    6    2    1    4   10\n#>  [8,]    9    6    2    5    7\n#>  [9,]    7    9    8    7    6\n#> [10,]    3    3    7    9    9\n\n# Simulate sampling distributions\n# Take 1000 samples of size 30 and calculate mean of each\nset.seed(123)\nsample_means <- replicate(1000, mean(rnorm(30, mean = 100, sd = 15)))\nhist(sample_means, main = \"Distribution of Sample Means\",\n     col = \"lightgreen\", xlab = \"Sample Mean\")\n```\n\n::: {.cell-output-display}\n![](07-r-programming_files/figure-html/replicate-examples-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nThe `replicate()` function belongs to the \"apply\" family and returns a matrix (if results are vectors of equal length) or a list (if results vary in length).\n\n## Useful Numeric Transformations {#sec-numeric-transformations}\n\nR and the tidyverse provide many functions for transforming numeric data. These are particularly useful within `mutate()` operations.\n\n### Cumulative and Running Aggregates\n\nBase R provides functions for running (cumulative) calculations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5)\n\ncumsum(x)   # Running sum: 1, 3, 6, 10, 15\n#> [1]  1  3  6 10 15\ncumprod(x)  # Running product: 1, 2, 6, 24, 120\n#> [1]   1   2   6  24 120\ncummax(x)   # Running maximum\n#> [1] 1 2 3 4 5\ncummin(x)   # Running minimum\n#> [1] 1 1 1 1 1\n\n# Useful for time series data\ndaily_cases <- c(10, 15, 8, 22, 18)\ncumsum(daily_cases)  # Total cases over time\n#> [1] 10 25 33 55 73\n```\n:::\n\n\n### Offsets with `lead()` and `lag()`\n\nThe `dplyr::lead()` and `dplyr::lag()` functions let you reference values before or after the current position:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nx <- c(10, 20, 30, 40, 50)\n\nlag(x)   # Previous value: NA, 10, 20, 30, 40\n#> [1] NA 10 20 30 40\nlead(x)  # Next value: 20, 30, 40, 50, NA\n#> [1] 20 30 40 50 NA\n\n# Calculate differences from previous value\nx - lag(x)\n#> [1] NA 10 10 10 10\n\n# Detect changes\nx != lag(x)\n#> [1]   NA TRUE TRUE TRUE TRUE\n\n# Lag by more than one position\nlag(x, n = 2)\n#> [1] NA NA 10 20 30\n```\n:::\n\n\nThis is invaluable for time series analysis, detecting changes, and calculating growth rates.\n\n### Ranking Values\n\ndplyr provides several ranking functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(5, 1, 3, 2, 2, NA)\n\nmin_rank(x)      # Standard competition ranking (1, 2, 2, 4)\n#> [1]  5  1  4  2  2 NA\ndense_rank(x)    # No gaps after ties (1, 2, 2, 3)\n#> [1]  4  1  3  2  2 NA\nrow_number(x)    # Unique ranks (ties broken by position)\n#> [1]  5  1  4  2  3 NA\n\n# Rank in descending order\nmin_rank(desc(x))\n#> [1]  1  5  2  3  3 NA\n\n# Practical example: find top 3 values\ndf <- tibble(gene = c(\"A\", \"B\", \"C\", \"D\", \"E\"),\n             expression = c(5.2, 8.1, 3.4, 9.7, 6.5))\ndf |> filter(min_rank(desc(expression)) <= 3)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|gene | expression|\n|:----|----------:|\n|B    |        8.1|\n|D    |        9.7|\n|E    |        6.5|\n\n</div>\n:::\n:::\n\n\n### Binning Numbers with `cut()`\n\nThe `cut()` function divides continuous data into discrete bins:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nages <- c(15, 25, 35, 45, 55, 65, 75)\n\n# Create age groups\ncut(ages, breaks = c(0, 18, 35, 55, 100))\n#> [1] (0,18]   (18,35]  (18,35]  (35,55]  (35,55]  (55,100] (55,100]\n#> Levels: (0,18] (18,35] (35,55] (55,100]\n\n# Custom labels\ncut(ages,\n    breaks = c(0, 18, 35, 55, 100),\n    labels = c(\"minor\", \"young_adult\", \"middle_aged\", \"senior\"))\n#> [1] minor       young_adult young_adult middle_aged middle_aged senior     \n#> [7] senior     \n#> Levels: minor young_adult middle_aged senior\n\n# Include lowest value and control interval direction\ncut(ages, breaks = c(0, 18, 35, 55, 100),\n    include.lowest = TRUE, right = FALSE)\n#> [1] [0,18)   [18,35)  [35,55)  [35,55)  [55,100] [55,100] [55,100]\n#> Levels: [0,18) [18,35) [35,55) [55,100]\n```\n:::\n\n\nThis is particularly useful for creating categorical variables from continuous measurements for analysis or visualization.\n\n## Cleaning Up Your Environment {#sec-cleanup}\n\nAs you work in R, your environment accumulates objects. Periodically cleaning up helps manage memory and avoid confusion.\n\n### Removing Objects\n\nUse `rm()` to remove objects from your environment:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Remove a single object\nrm(x)\n\n# Remove multiple objects\nrm(x, y, z)\n\n# Remove all objects (use with caution!)\nrm(list = ls())\n```\n:::\n\n\n::: {.callout-warning}\n`rm(list = ls())` removes everything in your environment. Use it intentionally, typically at the start of a script to ensure a clean slate, but never in a shared function or package.\n:::\n\n### Closing Graphics Devices\n\nWhen working with plots, graphics devices can accumulate. Use `dev.off()` to close them:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Close the current graphics device\ndev.off()\n\n# Close all graphics devices\ngraphics.off()\n\n# List open devices\ndev.list()\n```\n:::\n\n\nThis is especially important when saving plots to files—if you don't close the device, the file may not be properly saved:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Save a plot to PDF\npdf(\"my_plot.pdf\")\nplot(1:10, (1:10)^2)\ndev.off()  # Essential! Closes the file and finalizes it\n\n# Similarly for PNG\npng(\"my_plot.png\", width = 800, height = 600)\nplot(1:10, (1:10)^2)\ndev.off()\n```\n:::\n\n\n### Checking Your Environment\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# List all objects in the environment\nls()\n\n# List objects matching a pattern\nls(pattern = \"data\")\n\n# Check if an object exists\nexists(\"my_variable\")\n\n# See environment size\nobject.size(x)  # Size of one object\n```\n:::\n\n\n## Summary {#sec-r-summary}\n\nThis chapter introduced R programming fundamentals:\n\n- R is designed for statistical computing with excellent graphics\n- Everything in R is an object with a class and type; use `class()`, `typeof()`, and `str()` to explore objects\n- RStudio provides an integrated development environment\n- Variables are assigned with `<-`; R is case-sensitive; avoid reserved words and shadowing built-in functions\n- Vectors are the fundamental data structure; operations are vectorized\n- Logical operators (`&`, `|`, `!`, `%in%`) and comparison operators enable conditional logic\n- Floating-point comparisons require `all.equal()` instead of `==`\n- Data frames hold tabular data with columns of different types\n- Lists can contain elements of different types and lengths\n- Matrices are optimized for numerical computations\n- Functions perform operations; use `?function`, vignettes, and demos for help\n- Packages extend R's capabilities; watch for namespace conflicts when loading multiple packages\n- The split-apply-combine pattern (`tapply()`, `aggregate()`, `apply()`) is fundamental to data analysis\n- Conditional logic (`ifelse()`) and loops enable programmatic control\n- Writing custom functions allows you to encapsulate repeated operations\n- R reads/writes CSV, TSV, and Excel files easily\n- Basic plotting is built-in; ggplot2 offers advanced graphics\n- Use `rm()` and `dev.off()` to clean up your environment and graphics devices\n\nThese fundamentals prepare you for more advanced R programming, including the tidyverse packages covered in subsequent chapters.\n\n## Exercises {.unnumbered}\n\n::: {.callout-tip title=\"Practice Exercises\"}\n**Exercise 1: Vector Operations**\n\n1. Create a vector of the first 20 integers\n2. Calculate the mean, median, and standard deviation\n3. Create a new vector containing only the even numbers\n4. Calculate the sum of squares\n\n**Exercise 2: Data Frame Practice**\n\nCreate a data frame representing an experiment:\n1. Include columns for: sample_id, group (control/treatment), measurement\n2. Add 10 rows of sample data\n3. Calculate the mean measurement for each group\n4. Add a new column with log-transformed measurements\n\n**Exercise 3: Lists and Matrices**\n\n1. Create a list containing three components: a numeric vector, a character vector, and a data frame\n2. Use indexing to extract the second element of the first component\n3. Create a 4x4 matrix filled with the numbers 1-16\n4. Calculate row sums and column means using `apply()`\n\n**Exercise 4: Split-Apply-Combine**\n\nUsing the built-in `mtcars` dataset:\n1. Calculate the mean `mpg` for each number of cylinders (`cyl`) using `tapply()`\n2. Use `aggregate()` to find the mean and standard deviation of `hp` by `cyl`\n3. Write a custom function that returns the range (max - min) of a vector\n4. Apply your function to find the range of `mpg` for each gear type\n\n**Exercise 5: Programming Practice**\n\n1. Use `ifelse()` to create a new vector that categorizes `mtcars$mpg` as \"efficient\" (≥25) or \"inefficient\" (<25)\n2. Write a for loop that calculates the cumulative sum of the first 10 integers\n3. Create a function called `standardize()` that takes a vector and returns z-scores: (x - mean) / sd\n4. Test your function on a vector of your choice\n\n**Exercise 6: Random Simulation**\n\n1. Generate 1000 random samples from a normal distribution with mean=100 and sd=15\n2. Create a histogram of the data\n3. Calculate what proportion of values fall between 85 and 115\n4. Compare to the theoretical proportion for a normal distribution\n\n**Exercise 7: File I/O**\n\n1. Create a data frame with experimental data\n2. Save it as a CSV file\n3. Read it back into a new variable\n4. Verify the data matches the original\n:::\n\n## Additional Resources {.unnumbered}\n\n**Official Documentation and Tutorials**\n\n- [The R Project Homepage](https://www.r-project.org) — Official R website with downloads and documentation\n- [An Introduction to R](https://cran.r-project.org/doc/manuals/R-intro.html) — Comprehensive official manual\n- [R for Data Science](https://r4ds.had.co.nz) — Free online book covering the tidyverse approach\n\n**Quick References**\n\n- [Quick-R](https://www.statmethods.net) — Concise reference for common R tasks\n- [RStudio Cheat Sheets](https://posit.co/resources/cheatsheets/) — One-page references for popular packages\n\n**Bioinformatics-Specific**\n\n- [Bioconductor](https://www.bioconductor.org) — R packages for bioinformatics and computational biology\n- [A Primer for Computational Biology](http://library.open.oregonstate.edu/computationalbiology/) — O'Neil, S.T. 2017\n\n**Recommended Books**\n\n- Logan, M. 2010. *Biostatistical Design and Analysis Using R* — Excellent introduction to R for statistical analysis in the life sciences\n",
    "supporting": [
      "07-r-programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}