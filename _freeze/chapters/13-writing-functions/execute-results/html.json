{
  "hash": "bbb462e6f6429f9983739060934e6faf",
  "result": {
    "engine": "knitr",
    "markdown": "# Writing Functions in R {#sec-writing-functions}\n\n\n\n::: {.callout-note title=\"Learning Objectives\"}\nAfter completing this chapter, you will be able to:\n\n- Write your own R functions using proper syntax\n- Specify function arguments with default values\n- Return single or multiple values from functions\n- Use control flow (if/else, case_when) within functions\n- Understand lexical scoping and function environments\n- Apply functional programming principles with lapply and purrr\n- Iterate over single and multiple inputs efficiently\n- Choose between for loops and functional approaches\n:::\n\n## Why Write Your Own Functions? {#sec-why-functions}\n\nThroughout this book, we've used many functions: some from base R (like `mean()` and `sum()`), others from packages (like `dplyr::filter()` and `ggplot2::ggplot()`). But the real power of programming comes from writing your own functions.\n\nFunctions allow you to:\n\n- **Avoid repetition**: Write code once, use it many times\n- **Reduce errors**: Fix bugs in one place rather than many\n- **Improve readability**: Give meaningful names to complex operations\n- **Share code**: Package your solutions for others to use\n\nIn biosciences, you'll often need custom functions for tasks like:\n\n- Calculating enzyme kinetics parameters\n- Normalizing gene expression data\n- Computing population genetics statistics\n- Processing experimental replicates\n\n## Basic Function Syntax {#sec-function-syntax}\n\nAll R functions follow the same basic syntax:\n\n```r\nfunction_name = function(ARGUMENTS) {\n  OPERATIONS\n  return(VALUE)\n}\n```\n\nLet's break this down:\n\n- **function_name**: A descriptive name for your function\n- **ARGUMENTS**: Input values the function accepts\n- **OPERATIONS**: What the function does\n- **return(VALUE)**: What the function gives back\n\nFor short functions, you can write everything on one line:\n\n```r\nmy_short_func = function(x) x^2\n```\n\n::: {.callout-tip}\nGive your functions short, descriptive names that indicate what they do. `calculate_gc_content` is better than `func1` or `cgc`.\n:::\n\n## A Simple Example: GC Content Calculator {#sec-gc-example}\n\nLet's write a function that calculates the GC content of a DNA sequence --- the proportion of guanine (G) and cytosine (C) bases.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_content = function(sequence) {\n  # Convert to uppercase for consistency\n  seq_upper = toupper(sequence)\n\n  # Count G and C bases\n  gc_count = str_count(seq_upper, \"[GC]\")\n\n  # Calculate total length (excluding any non-ATGC characters)\n  total_bases = str_count(seq_upper, \"[ATGC]\")\n\n  # Return GC proportion\n  gc_count / total_bases\n}\n```\n:::\n\n\nTest it:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_content(\"ATGCGATCGATCG\")\n#> [1] 0.5384615\ngc_content(\"atgcGATCgatcg\")  # Works with mixed case\n#> [1] 0.5384615\ngc_content(\"AAAAAATTTTTT\")   # Low GC content\n#> [1] 0\ngc_content(\"GGGGGGCCCCCC\")   # High GC content\n#> [1] 1\n```\n:::\n\n\n### Specifying Return Values\n\nIn the example above, R automatically returned the last evaluated expression. However, it's good practice to use explicit `return()` statements, especially for complex functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_content = function(sequence) {\n  seq_upper = toupper(sequence)\n  gc_count = str_count(seq_upper, \"[GC]\")\n  total_bases = str_count(seq_upper, \"[ATGC]\")\n  gc_proportion = gc_count / total_bases\n\n  return(gc_proportion)  # Explicit return\n}\n```\n:::\n\n\n### Returning Multiple Values\n\nWhat if we want to return more than one piece of information? Use a list or data frame:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_content_detailed = function(sequence) {\n  seq_upper = toupper(sequence)\n\n  # Count each base\n  a_count = str_count(seq_upper, \"A\")\n  t_count = str_count(seq_upper, \"T\")\n  g_count = str_count(seq_upper, \"G\")\n  c_count = str_count(seq_upper, \"C\")\n\n  total = a_count + t_count + g_count + c_count\n  gc_prop = (g_count + c_count) / total\n\n  # Return as a data frame\n  result = tibble(\n    sequence = sequence,\n    length = total,\n    A = a_count,\n    T = t_count,\n    G = g_count,\n    C = c_count,\n    gc_content = round(gc_prop, 4)\n  )\n\n  return(result)\n}\n\ngc_content_detailed(\"ATGCGATCGATCGATCG\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sequence          | length|  A|  T|  G|  C| gc_content|\n|:-----------------|------:|--:|--:|--:|--:|----------:|\n|ATGCGATCGATCGATCG |     17|  4|  4|  5|  4|     0.5294|\n\n</div>\n:::\n:::\n\n\n### Default Argument Values\n\nYou can specify default values for arguments. This is useful when most calls will use the same value:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_content = function(sequence, digits = 4) {\n  seq_upper = toupper(sequence)\n  gc_count = str_count(seq_upper, \"[GC]\")\n  total_bases = str_count(seq_upper, \"[ATGC]\")\n  gc_proportion = gc_count / total_bases\n\n  return(round(gc_proportion, digits))\n}\n\ngc_content(\"ATGCGATCGATCG\")       # Uses default 4 digits\n#> [1] 0.5385\ngc_content(\"ATGCGATCGATCG\", 2)    # Override to 2 digits\n#> [1] 0.54\n```\n:::\n\n\n## Environments and Lexical Scoping {#sec-lexical-scoping}\n\nAn important concept to understand is that functions operate in their own **environment**. Objects created inside a function don't appear in your global environment:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntest_function = function(x) {\n  internal_var = x * 2  # This stays inside the function\n  return(internal_var)\n}\n\nresult = test_function(5)\nresult\n#> [1] 10\n\n# Try to access internal_var - it doesn't exist in the global environment\n# internal_var  # Would produce an error\n```\n:::\n\n\nThis is called **lexical scoping**. R looks for objects in this order:\n\n1. Inside the function\n2. In the environment where the function was defined\n3. In parent environments, up to the global environment\n\n::: {.callout-important}\nFunctions are \"sandboxed\" --- they don't pollute your global environment with intermediate variables. This makes code cleaner and reduces the risk of naming conflicts.\n:::\n\n## Control Flow in Functions {#sec-control-flow}\n\n### Using if/else\n\nControl flow allows your functions to behave differently based on conditions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calculate enzyme velocity using Michaelis-Menten kinetics\nenzyme_velocity = function(substrate, vmax, km, inhibitor = NULL, ki = NULL) {\n\n  if (is.null(inhibitor)) {\n    # No inhibitor: standard Michaelis-Menten\n    velocity = (vmax * substrate) / (km + substrate)\n  } else {\n    # Competitive inhibition\n    if (is.null(ki)) {\n      stop(\"If inhibitor concentration is provided, ki must also be specified\")\n    }\n    apparent_km = km * (1 + inhibitor / ki)\n    velocity = (vmax * substrate) / (apparent_km + substrate)\n  }\n\n  return(velocity)\n}\n\n# Test without inhibitor\nenzyme_velocity(substrate = 10, vmax = 100, km = 5)\n#> [1] 66.66667\n\n# Test with inhibitor\nenzyme_velocity(substrate = 10, vmax = 100, km = 5, inhibitor = 2, ki = 3)\n#> [1] 54.54545\n```\n:::\n\n\n### Using case_when for Multiple Conditions\n\nWhen you have many conditions, nested `if/else` statements become hard to read. Use `dplyr::case_when()` instead:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Classify gene expression fold changes\nclassify_expression = function(fold_change) {\n  category = case_when(\n    fold_change >= 2 ~ \"strongly_upregulated\",\n    fold_change >= 1.5 ~ \"upregulated\",\n    fold_change <= 0.5 ~ \"strongly_downregulated\",\n    fold_change <= 0.67 ~ \"downregulated\",\n    TRUE ~ \"unchanged\"\n  )\n  return(category)\n}\n\n# Test with a vector of fold changes\nfold_changes = c(0.3, 0.6, 1.0, 1.6, 2.5)\nclassify_expression(fold_changes)\n#> [1] \"strongly_downregulated\" \"downregulated\"          \"unchanged\"             \n#> [4] \"upregulated\"            \"strongly_upregulated\"\n```\n:::\n\n\nThe equivalent `data.table::fcase()` function works similarly:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclassify_expression_dt = function(fold_change) {\n  fcase(\n    fold_change >= 2, \"strongly_upregulated\",\n    fold_change >= 1.5, \"upregulated\",\n    fold_change <= 0.5, \"strongly_downregulated\",\n    fold_change <= 0.67, \"downregulated\",\n    default = \"unchanged\"\n  )\n}\n\nclassify_expression_dt(fold_changes)\n#> [1] \"strongly_downregulated\" \"downregulated\"          \"unchanged\"             \n#> [4] \"upregulated\"            \"strongly_upregulated\"\n```\n:::\n\n\n## Iteration and Functional Programming {#sec-iteration}\n\n### The Problem with for Loops\n\nYou'll often need to apply the same operation to many inputs. The traditional approach uses `for` loops:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calculate GC content for multiple sequences\nsequences = c(\"ATGCGATCG\", \"GGGGCCCC\", \"AAAATTTT\", \"ATATATAT\")\n\n# Using a for loop\ngc_results = NULL\nfor (i in 1:length(sequences)) {\n  gc_results[i] = gc_content(sequences[i])\n}\ngc_results\n#> [1] 0.5556 1.0000 0.0000 0.0000\n```\n:::\n\n\nThis works, but has several problems:\n\n1. **Verbose**: Lots of boilerplate code\n2. **Error-prone**: Easy to make off-by-one errors\n3. **Pollutes environment**: The loop variable `i` persists after the loop\n4. **Not R-like**: R is designed for vectorized operations\n\n### Functional Programming with lapply\n\nThe **functional programming** approach treats iteration as applying a function across elements:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Much cleaner!\ngc_results = lapply(sequences, gc_content)\ngc_results\n#> [[1]]\n#> [1] 0.5556\n#> \n#> [[2]]\n#> [1] 1\n#> \n#> [[3]]\n#> [1] 0\n#> \n#> [[4]]\n#> [1] 0\n```\n:::\n\n\nThe result is a list. To get a vector instead:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_results = sapply(sequences, gc_content)\ngc_results\n#> ATGCGATCG  GGGGCCCC  AAAATTTT  ATATATAT \n#>    0.5556    1.0000    0.0000    0.0000\n```\n:::\n\n\nTo combine results into a data frame, use our detailed function with `bind_rows()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlapply(sequences, gc_content_detailed) %>%\n  bind_rows()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sequence  | length|  A|  T|  G|  C| gc_content|\n|:---------|------:|--:|--:|--:|--:|----------:|\n|ATGCGATCG |      9|  2|  2|  3|  2|     0.5556|\n|GGGGCCCC  |      8|  0|  0|  4|  4|     1.0000|\n|AAAATTTT  |      8|  4|  4|  0|  0|     0.0000|\n|ATATATAT  |      8|  4|  4|  0|  0|     0.0000|\n\n</div>\n:::\n:::\n\n\n### Using purrr for Iteration\n\nThe **purrr** package provides a consistent and powerful set of mapping functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# map() returns a list (like lapply)\nmap(sequences, gc_content)\n#> [[1]]\n#> [1] 0.5556\n#> \n#> [[2]]\n#> [1] 1\n#> \n#> [[3]]\n#> [1] 0\n#> \n#> [[4]]\n#> [1] 0\n\n# map_dbl() returns a numeric vector\nmap_dbl(sequences, gc_content)\n#> [1] 0.5556 1.0000 0.0000 0.0000\n\n# map_df() returns a data frame\nmap_df(sequences, gc_content_detailed)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sequence  | length|  A|  T|  G|  C| gc_content|\n|:---------|------:|--:|--:|--:|--:|----------:|\n|ATGCGATCG |      9|  2|  2|  3|  2|     0.5556|\n|GGGGCCCC  |      8|  0|  0|  4|  4|     1.0000|\n|AAAATTTT  |      8|  4|  4|  0|  0|     0.0000|\n|ATATATAT  |      8|  4|  4|  0|  0|     0.0000|\n\n</div>\n:::\n:::\n\n\n### Creating and Reusing Named Functions\n\nFor complex analyses, separate the function definition from iteration:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Define a function for processing protein sequences\nanalyze_protein = function(sequence) {\n  seq_upper = toupper(sequence)\n  length = nchar(seq_upper)\n\n  # Count hydrophobic residues (simplified)\n  hydrophobic = str_count(seq_upper, \"[AILMFVPW]\")\n\n  # Count charged residues\n  charged = str_count(seq_upper, \"[DEKRH]\")\n\n  tibble(\n    sequence = sequence,\n    length = length,\n    hydrophobic_pct = round(hydrophobic / length * 100, 1),\n    charged_pct = round(charged / length * 100, 1)\n  )\n}\n\n# Some sample protein sequences\nproteins = c(\n  \"MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVKALPDAQFEVVHSLAKWKRQQIAAALEHHHHHH\",\n  \"MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSH\",\n  \"GLSDGEWQQVLNVWGKVEADIAGHGQEVLIRLFTGHPETLEKFDKFKHLKTEAEMKASEDLKKHGTVVLTALGGILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISDAIIHVLHSKHPGDFGADAQGAMTKALELFRNDIAAKYKELGFQG\"\n)\n\n# Apply to all proteins\nmap_df(proteins, analyze_protein)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sequence                                                                                                                                                  | length| hydrophobic_pct| charged_pct|\n|:---------------------------------------------------------------------------------------------------------------------------------------------------------|------:|---------------:|-----------:|\n|MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVKALPDAQFEVVHSLAKWKRQQIAAALEHHHHHH                                                              |     92|            42.4|        32.6|\n|MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSH                                                                                                       |     51|            47.1|        25.5|\n|GLSDGEWQQVLNVWGKVEADIAGHGQEVLIRLFTGHPETLEKFDKFKHLKTEAEMKASEDLKKHGTVVLTALGGILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISDAIIHVLHSKHPGDFGADAQGAMTKALELFRNDIAAKYKELGFQG |    153|            41.2|        34.6|\n\n</div>\n:::\n:::\n\n\n## Iterating Over Multiple Inputs {#sec-multiple-inputs}\n\nSometimes you need to iterate over multiple inputs simultaneously.\n\n### Using pmap for Multiple Arguments\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Simulate growth curves with different parameters\nsimulate_growth = function(time, k, n0, carrying_capacity) {\n  # Logistic growth model\n  n = carrying_capacity / (1 + ((carrying_capacity - n0) / n0) * exp(-k * time))\n\n  tibble(\n    time = time,\n    k = k,\n    n0 = n0,\n    K = carrying_capacity,\n    population = round(n, 0)\n  )\n}\n\n# Parameters for different bacterial strains\nparams = tibble(\n  k = c(0.5, 0.8, 0.3),              # Growth rates\n  n0 = c(100, 50, 200),              # Initial populations\n  carrying_capacity = c(10000, 15000, 8000)  # Carrying capacities\n)\n\n# Run simulations for each strain at time = 10\npmap_df(params, ~simulate_growth(time = 10, k = ..1, n0 = ..2, carrying_capacity = ..3))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| time|   k|  n0|     K| population|\n|----:|---:|---:|-----:|----------:|\n|   10| 0.5| 100| 10000|       5999|\n|   10| 0.8|  50| 15000|      13633|\n|   10| 0.3| 200|  8000|       2720|\n\n</div>\n:::\n:::\n\n\n### Using a Data Frame of Inputs\n\nA cleaner approach for complex cases is to pass a data frame of input combinations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create all parameter combinations\nsimulation_params = expand.grid(\n  time = seq(0, 20, by = 2),\n  strain = c(\"wild_type\", \"mutant_A\", \"mutant_B\")\n) %>%\n  as_tibble() %>%\n  mutate(\n    k = case_when(\n      strain == \"wild_type\" ~ 0.5,\n      strain == \"mutant_A\" ~ 0.8,\n      strain == \"mutant_B\" ~ 0.3\n    ),\n    n0 = 100,\n    carrying_capacity = 10000\n  )\n\n# Function that takes a row of parameters\nrun_simulation = function(row_data) {\n  simulate_growth(\n    time = row_data$time,\n    k = row_data$k,\n    n0 = row_data$n0,\n    carrying_capacity = row_data$carrying_capacity\n  ) %>%\n    mutate(strain = row_data$strain)\n}\n\n# Run all simulations\nresults = map_df(1:nrow(simulation_params), function(i) {\n  run_simulation(simulation_params[i, ])\n})\n\n# Plot the results\nggplot(results, aes(x = time, y = population, color = strain)) +\n  geom_line(linewidth = 1) +\n  geom_point() +\n  labs(\n    title = \"Bacterial Growth Curves\",\n    x = \"Time (hours)\",\n    y = \"Population Size\",\n    color = \"Strain\"\n  ) +\n  scale_y_continuous(labels = scales::comma)\n```\n\n::: {.cell-output-display}\n![](13-writing-functions_files/figure-html/df-inputs-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Best Practices for Writing Functions {#sec-function-best-practices}\n\n### 1. Use Descriptive Names\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Good names\ncalculate_gc_content()\nnormalize_expression()\nfit_growth_curve()\n\n# Bad names\nfunc1()\ndo_stuff()\nf()\n```\n:::\n\n\n### 2. Document Your Functions\n\nAdd comments explaining what the function does, its arguments, and return value:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Calculate the melting temperature of a DNA primer\n#\n# Uses the Wallace rule for short oligonucleotides (<14 bp)\n# or the nearest-neighbor method for longer sequences\n#\n# Arguments:\n#   sequence: DNA sequence (string of A, T, G, C)\n#   method: \"wallace\" or \"nearest_neighbor\"\n#\n# Returns:\n#   Melting temperature in degrees Celsius\n\ncalculate_tm = function(sequence, method = \"wallace\") {\n  seq_upper = toupper(sequence)\n  length = nchar(seq_upper)\n\n  a_count = str_count(seq_upper, \"A\")\n  t_count = str_count(seq_upper, \"T\")\n  g_count = str_count(seq_upper, \"G\")\n  c_count = str_count(seq_upper, \"C\")\n\n  if (method == \"wallace\" || length < 14) {\n    # Wallace rule: Tm = 2(A+T) + 4(G+C)\n    tm = 2 * (a_count + t_count) + 4 * (g_count + c_count)\n  } else {\n    # Simplified nearest-neighbor approximation\n    tm = 64.9 + 41 * (g_count + c_count - 16.4) / length\n  }\n\n  return(tm)\n}\n\ncalculate_tm(\"ATGCGATCGATCG\")\n#> [1] 40\n```\n:::\n\n\n### 3. Validate Inputs\n\nCheck that inputs are valid before processing:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngc_content_safe = function(sequence) {\n  # Check input type\n  if (!is.character(sequence)) {\n    stop(\"Sequence must be a character string\")\n  }\n\n  # Check for valid DNA characters\n  seq_upper = toupper(sequence)\n  invalid_chars = str_remove_all(seq_upper, \"[ATGCN]\")\n  if (nchar(invalid_chars) > 0) {\n    warning(paste(\"Invalid characters removed:\", invalid_chars))\n  }\n\n  gc_count = str_count(seq_upper, \"[GC]\")\n  total_bases = str_count(seq_upper, \"[ATGC]\")\n\n  if (total_bases == 0) {\n    stop(\"No valid DNA bases found in sequence\")\n  }\n\n  return(gc_count / total_bases)\n}\n\ngc_content_safe(\"ATGCGATCG\")     # Works fine\n#> [1] 0.5555556\ngc_content_safe(\"ATGCXYZGATCG\")  # Warning about invalid characters\n#> [1] 0.5555556\n```\n:::\n\n\n### 4. Keep Functions Focused\n\nEach function should do one thing well. Break complex operations into smaller functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Instead of one giant function, break it up:\n\n# Step 1: Clean the sequence\nclean_sequence = function(seq) {\n  seq %>%\n    toupper() %>%\n    str_remove_all(\"[^ATGC]\")\n}\n\n# Step 2: Calculate base composition\nbase_composition = function(seq) {\n  tibble(\n    A = str_count(seq, \"A\"),\n    T = str_count(seq, \"T\"),\n    G = str_count(seq, \"G\"),\n    C = str_count(seq, \"C\")\n  )\n}\n\n# Step 3: Derive statistics\nsequence_stats = function(composition) {\n  total = sum(composition)\n  composition %>%\n    mutate(\n      total = total,\n      gc_content = (G + C) / total,\n      at_content = (A + T) / total\n    )\n}\n\n# Combine them in a pipeline\n\"atgcGATCgatcgNNNN\" %>%\n  clean_sequence() %>%\n  base_composition() %>%\n  sequence_stats()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  A|  T|  G|  C| total| gc_content| at_content|\n|--:|--:|--:|--:|-----:|----------:|----------:|\n|  3|  3|  4|  3|    13|  0.5384615|  0.4615385|\n\n</div>\n:::\n:::\n\n\n## Summary {#sec-functions-summary}\n\nWriting functions is a fundamental programming skill that will dramatically improve your data analysis workflows:\n\n- **Basic syntax**: `function_name = function(args) { body; return(value) }`\n- **Return values**: Use explicit `return()` statements; return lists or data frames for multiple values\n- **Default arguments**: Provide sensible defaults for commonly-used parameter values\n- **Lexical scoping**: Functions operate in their own environment, keeping your global environment clean\n- **Control flow**: Use `if/else` and `case_when()` to handle different conditions\n- **Functional programming**: Prefer `lapply()`/`map()` over for loops for iteration\n- **Multiple inputs**: Use `pmap()` or data frame inputs for complex parameter combinations\n\nThe next chapter will show you how to debug functions when things go wrong, catch user errors gracefully, and cache results for expensive computations.\n\n::: {.callout-tip}\nFor quick reference on R function syntax and functional programming tools like `lapply()` and `purrr`, see @sec-appendix-r.\n:::\n\n## Additional Reading {.unnumbered}\n\nTo deepen your understanding of functions and functional programming in R:\n\n- **[R for Data Science: Functions](https://r4ds.hadley.nz/functions)** — Excellent introduction to writing functions\n- **[Advanced R: Functions](https://adv-r.hadley.nz/functions.html)** by Hadley Wickham — Deep dive into function mechanics\n- **[purrr Documentation](https://purrr.tidyverse.org/)** — Complete guide to functional programming with purrr\n- **[R for Data Science: Iteration](https://r4ds.hadley.nz/iteration)** — More on map functions and iteration\n\nFor advanced function development:\n\n- **[Advanced R: Functional Programming](https://adv-r.hadley.nz/fp.html)** — Closures, function factories, and more\n- **[R Packages](https://r-pkgs.org/)** by Wickham and Bryan — When you're ready to package your functions\n\n## Exercises {.unnumbered}\n\n::: {.callout-tip title=\"Practice Exercises\"}\n**Exercise 1: Basic Function**\n\nWrite a function called `count_codons()` that takes a DNA sequence and returns the number of complete codons (groups of 3 nucleotides). For example, \"ATGCGA\" has 2 complete codons.\n\n**Exercise 2: Function with Multiple Returns**\n\nWrite a function `analyze_sequence()` that takes a DNA sequence and returns a data frame with:\n- The sequence length\n- GC content\n- Number of each base (A, T, G, C)\n- Whether it starts with a start codon (ATG)\n- Whether it ends with a stop codon (TAA, TAG, or TGA)\n\n**Exercise 3: Control Flow**\n\nWrite a function `translate_codon()` that takes a three-letter codon and returns the corresponding amino acid (use a simplified table with just 5-10 codons). Include error handling for invalid inputs.\n\n**Exercise 4: Iteration**\n\nYou have a vector of 10 DNA sequences. Use `map_df()` to apply your `analyze_sequence()` function from Exercise 2 to all of them and combine the results into a single data frame.\n\n**Exercise 5: Multiple Inputs**\n\nWrite a function `dilution_series()` that takes an initial concentration and dilution factor, then returns a data frame showing the concentration at each step for a specified number of dilutions. Use `pmap()` to apply this to multiple starting conditions.\n\n**Exercise 6: Refactoring**\n\nTake the following for loop and rewrite it using functional programming:\n\n```r\nresults = c()\nfor (i in 1:length(sequences)) {\n  gc = gc_content(sequences[i])\n  if (gc > 0.5) {\n    results = c(results, \"high\")\n  } else {\n    results = c(results, \"low\")\n  }\n}\n```\n:::\n",
    "supporting": [
      "13-writing-functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}