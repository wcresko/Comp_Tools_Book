{
  "hash": "c6470d0aa6f29cc0cefd06dd8309b334",
  "result": {
    "engine": "knitr",
    "markdown": "# Working with Databases {#sec-databases}\n\n\n\n::: {.callout-note title=\"Learning Objectives\"}\nAfter completing this chapter, you will be able to:\n\n- Understand database fundamentals and when to use them\n- Connect to databases from R using DBI\n- Write basic SQL queries\n- Use dbplyr to work with databases using familiar dplyr syntax\n- Translate between dplyr operations and SQL\n- Work with in-process databases like duckdb for large datasets\n:::\n\n## Why Databases? {#sec-why-databases}\n\nA huge amount of scientific data lives in databases. While you can sometimes ask a collaborator to export a snapshot to a CSV file, this approach becomes painful quickly: every time you need updated data or a different subset, you must coordinate with another person. Being able to access databases directly gives you the data you need, when you need it.\n\nDatabases offer several advantages over flat files:\n\n- **Scale**: Databases can handle datasets too large to fit in memory\n- **Speed**: Indexes enable fast queries on specific subsets\n- **Concurrent access**: Multiple users can safely read and write simultaneously\n- **Data integrity**: Constraints prevent invalid data from being entered\n- **Security**: Fine-grained access controls protect sensitive information\n\nIn biosciences, you'll encounter databases for:\n\n- Genomic sequence repositories\n- Clinical trial data\n- Laboratory information management systems (LIMS)\n- Institutional data warehouses\n- Public resources like NCBI, Ensembl, and UniProt\n\n## Database Basics {#sec-db-basics}\n\nAt the simplest level, you can think of a database as a collection of data frames, called **tables** in database terminology. Like a data frame, a database table is a collection of named columns where every value in a column is the same type.\n\nThere are three key differences between data frames and database tables:\n\n1. **Storage**: Database tables are stored on disk and can be arbitrarily large. Data frames are stored in memory and limited by available RAM.\n\n2. **Indexes**: Database tables almost always have indexes that enable fast lookups without scanning every row—like the index of a book.\n\n3. **Orientation**: Traditional databases are **row-oriented** (optimized for adding records), while analytical databases are increasingly **column-oriented** (optimized for computing statistics).\n\n### Types of Database Systems\n\nDatabase management systems (DBMS) come in three main forms:\n\n| Type | Description | Examples |\n|:-----|:------------|:---------|\n| **Client-server** | Central server, multiple client connections | PostgreSQL, MySQL, SQL Server |\n| **Cloud** | Managed cloud services, auto-scaling | Amazon Redshift, Google BigQuery, Snowflake |\n| **In-process** | Runs entirely within your application | SQLite, DuckDB |\n\n: Types of database management systems {#tbl-dbms-types}\n\nFor learning and local analysis, in-process databases like **duckdb** are ideal—no server setup required, and they're designed for analytical workloads.\n\n## Connecting to Databases {#sec-db-connecting}\n\nTo connect to a database from R, you need two packages:\n\n- **DBI** (DataBase Interface): Provides generic functions for connecting, querying, and managing databases\n- **A database driver**: A package specific to your DBMS (e.g., RPostgres, RMariaDB, duckdb)\n\n### Using duckdb for Learning\n\nduckdb is a high-performance analytical database that's perfect for learning. It runs entirely within R and requires no external setup:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create an in-memory database (temporary, deleted when R closes)\ncon <- DBI::dbConnect(duckdb::duckdb())\n```\n:::\n\n\nFor persistent storage in a real project, specify a file path:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Persistent database stored in a file\ncon <- DBI::dbConnect(duckdb::duckdb(), dbdir = \"my_database.duckdb\")\n```\n:::\n\n\n### Connecting to Other Databases\n\nDifferent databases require different connection parameters:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# PostgreSQL\ncon <- DBI::dbConnect(\n  RPostgres::Postgres(),\n  host = \"database.example.com\",\n  port = 5432,\n  dbname = \"mydb\",\n  user = \"username\",\n  password = \"password\"\n)\n\n# MySQL/MariaDB\ncon <- DBI::dbConnect(\n  RMariaDB::MariaDB(),\n  host = \"localhost\",\n  dbname = \"mydb\",\n  username = \"user\"\n)\n```\n:::\n\n\n::: {.callout-tip}\nNever put passwords directly in your code! Use environment variables, the keyring package, or configuration files that aren't committed to version control.\n:::\n\n## Loading Data into a Database {#sec-db-loading}\n\nLet's create some example tables to work with. We'll use familiar datasets:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Write data frames to database tables\ndbWriteTable(con, \"mtcars\", mtcars)\ndbWriteTable(con, \"iris\", iris)\n\n# Verify the tables exist\ndbListTables(con)\n#> [1] \"iris\"   \"mtcars\"\n```\n:::\n\n\n### Reading Tables\n\nYou can read an entire table into R:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Read a table into R as a data frame\ncon |>\n  dbReadTable(\"mtcars\") |>\n  as_tibble()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  mpg| cyl|  disp|  hp| drat|    wt|  qsec| vs| am| gear| carb|\n|----:|---:|-----:|---:|----:|-----:|-----:|--:|--:|----:|----:|\n| 21.0|   6| 160.0| 110| 3.90| 2.620| 16.46|  0|  1|    4|    4|\n| 21.0|   6| 160.0| 110| 3.90| 2.875| 17.02|  0|  1|    4|    4|\n| 22.8|   4| 108.0|  93| 3.85| 2.320| 18.61|  1|  1|    4|    1|\n| 21.4|   6| 258.0| 110| 3.08| 3.215| 19.44|  1|  0|    3|    1|\n| 18.7|   8| 360.0| 175| 3.15| 3.440| 17.02|  0|  0|    3|    2|\n| 18.1|   6| 225.0| 105| 2.76| 3.460| 20.22|  1|  0|    3|    1|\n| 14.3|   8| 360.0| 245| 3.21| 3.570| 15.84|  0|  0|    3|    4|\n| 24.4|   4| 146.7|  62| 3.69| 3.190| 20.00|  1|  0|    4|    2|\n| 22.8|   4| 140.8|  95| 3.92| 3.150| 22.90|  1|  0|    4|    2|\n| 19.2|   6| 167.6| 123| 3.92| 3.440| 18.30|  1|  0|    4|    4|\n| 17.8|   6| 167.6| 123| 3.92| 3.440| 18.90|  1|  0|    4|    4|\n| 16.4|   8| 275.8| 180| 3.07| 4.070| 17.40|  0|  0|    3|    3|\n| 17.3|   8| 275.8| 180| 3.07| 3.730| 17.60|  0|  0|    3|    3|\n| 15.2|   8| 275.8| 180| 3.07| 3.780| 18.00|  0|  0|    3|    3|\n| 10.4|   8| 472.0| 205| 2.93| 5.250| 17.98|  0|  0|    3|    4|\n| 10.4|   8| 460.0| 215| 3.00| 5.424| 17.82|  0|  0|    3|    4|\n| 14.7|   8| 440.0| 230| 3.23| 5.345| 17.42|  0|  0|    3|    4|\n| 32.4|   4|  78.7|  66| 4.08| 2.200| 19.47|  1|  1|    4|    1|\n| 30.4|   4|  75.7|  52| 4.93| 1.615| 18.52|  1|  1|    4|    2|\n| 33.9|   4|  71.1|  65| 4.22| 1.835| 19.90|  1|  1|    4|    1|\n| 21.5|   4| 120.1|  97| 3.70| 2.465| 20.01|  1|  0|    3|    1|\n| 15.5|   8| 318.0| 150| 2.76| 3.520| 16.87|  0|  0|    3|    2|\n| 15.2|   8| 304.0| 150| 3.15| 3.435| 17.30|  0|  0|    3|    2|\n| 13.3|   8| 350.0| 245| 3.73| 3.840| 15.41|  0|  0|    3|    4|\n| 19.2|   8| 400.0| 175| 3.08| 3.845| 17.05|  0|  0|    3|    2|\n| 27.3|   4|  79.0|  66| 4.08| 1.935| 18.90|  1|  1|    4|    1|\n| 26.0|   4| 120.3|  91| 4.43| 2.140| 16.70|  0|  1|    5|    2|\n| 30.4|   4|  95.1| 113| 3.77| 1.513| 16.90|  1|  1|    5|    2|\n| 15.8|   8| 351.0| 264| 4.22| 3.170| 14.50|  0|  1|    5|    4|\n| 19.7|   6| 145.0| 175| 3.62| 2.770| 15.50|  0|  1|    5|    6|\n| 15.0|   8| 301.0| 335| 3.54| 3.570| 14.60|  0|  1|    5|    8|\n| 21.4|   4| 121.0| 109| 4.11| 2.780| 18.60|  1|  1|    4|    2|\n\n</div>\n:::\n:::\n\n\nHowever, for large tables this defeats the purpose of using a database. Instead, you'll want to query just the data you need.\n\n## SQL: The Language of Databases {#sec-sql}\n\n**SQL** (Structured Query Language) is the standard language for working with databases. While we'll primarily use dbplyr to write dplyr code that gets translated to SQL, understanding SQL basics is valuable.\n\n### Basic SQL Queries\n\nThe most common SQL operation is `SELECT`, which retrieves data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Run a SQL query directly\nsql <- \"SELECT mpg, cyl, hp FROM mtcars WHERE mpg > 25\"\nresult <- dbGetQuery(con, sql)\nas_tibble(result)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  mpg| cyl|  hp|\n|----:|---:|---:|\n| 32.4|   4|  66|\n| 30.4|   4|  52|\n| 33.9|   4|  65|\n| 27.3|   4|  66|\n| 26.0|   4|  91|\n| 30.4|   4| 113|\n\n</div>\n:::\n:::\n\n\n### SQL Query Structure\n\nA SQL query follows this general pattern:\n\n```sql\nSELECT columns\nFROM table\nWHERE conditions\nGROUP BY columns\nORDER BY columns\n```\n\nThe clauses must appear in this order, though not all are required.\n\n| Clause | Purpose | dplyr equivalent |\n|:-------|:--------|:-----------------|\n| `SELECT` | Choose columns, compute values | `select()`, `mutate()` |\n| `FROM` | Specify the table | The data frame name |\n| `WHERE` | Filter rows | `filter()` |\n| `GROUP BY` | Define groups for aggregation | `group_by()` |\n| `ORDER BY` | Sort results | `arrange()` |\n\n: SQL clauses and their dplyr equivalents {#tbl-sql-clauses}\n\n## Using dbplyr: dplyr for Databases {#sec-dbplyr}\n\n**dbplyr** is a dplyr backend that translates your dplyr code to SQL and runs it on the database. This means you can use familiar tidyverse syntax without learning SQL.\n\n### Creating a Database Reference\n\nUse `tbl()` to create a reference to a database table:\n\n\n::: {#tbl-reference .cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db <- tbl(con, \"mtcars\")\nmtcars_db\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  mpg| cyl|  disp|  hp| drat|    wt|  qsec| vs| am| gear| carb|\n|----:|---:|-----:|---:|----:|-----:|-----:|--:|--:|----:|----:|\n| 21.0|   6| 160.0| 110| 3.90| 2.620| 16.46|  0|  1|    4|    4|\n| 21.0|   6| 160.0| 110| 3.90| 2.875| 17.02|  0|  1|    4|    4|\n| 22.8|   4| 108.0|  93| 3.85| 2.320| 18.61|  1|  1|    4|    1|\n| 21.4|   6| 258.0| 110| 3.08| 3.215| 19.44|  1|  0|    3|    1|\n| 18.7|   8| 360.0| 175| 3.15| 3.440| 17.02|  0|  0|    3|    2|\n| 18.1|   6| 225.0| 105| 2.76| 3.460| 20.22|  1|  0|    3|    1|\n| 14.3|   8| 360.0| 245| 3.21| 3.570| 15.84|  0|  0|    3|    4|\n| 24.4|   4| 146.7|  62| 3.69| 3.190| 20.00|  1|  0|    4|    2|\n| 22.8|   4| 140.8|  95| 3.92| 3.150| 22.90|  1|  0|    4|    2|\n| 19.2|   6| 167.6| 123| 3.92| 3.440| 18.30|  1|  0|    4|    4|\n| 17.8|   6| 167.6| 123| 3.92| 3.440| 18.90|  1|  0|    4|    4|\n| 16.4|   8| 275.8| 180| 3.07| 4.070| 17.40|  0|  0|    3|    3|\n| 17.3|   8| 275.8| 180| 3.07| 3.730| 17.60|  0|  0|    3|    3|\n| 15.2|   8| 275.8| 180| 3.07| 3.780| 18.00|  0|  0|    3|    3|\n| 10.4|   8| 472.0| 205| 2.93| 5.250| 17.98|  0|  0|    3|    4|\n| 10.4|   8| 460.0| 215| 3.00| 5.424| 17.82|  0|  0|    3|    4|\n| 14.7|   8| 440.0| 230| 3.23| 5.345| 17.42|  0|  0|    3|    4|\n| 32.4|   4|  78.7|  66| 4.08| 2.200| 19.47|  1|  1|    4|    1|\n| 30.4|   4|  75.7|  52| 4.93| 1.615| 18.52|  1|  1|    4|    2|\n| 33.9|   4|  71.1|  65| 4.22| 1.835| 19.90|  1|  1|    4|    1|\n| 21.5|   4| 120.1|  97| 3.70| 2.465| 20.01|  1|  0|    3|    1|\n| 15.5|   8| 318.0| 150| 2.76| 3.520| 16.87|  0|  0|    3|    2|\n| 15.2|   8| 304.0| 150| 3.15| 3.435| 17.30|  0|  0|    3|    2|\n| 13.3|   8| 350.0| 245| 3.73| 3.840| 15.41|  0|  0|    3|    4|\n| 19.2|   8| 400.0| 175| 3.08| 3.845| 17.05|  0|  0|    3|    2|\n| 27.3|   4|  79.0|  66| 4.08| 1.935| 18.90|  1|  1|    4|    1|\n| 26.0|   4| 120.3|  91| 4.43| 2.140| 16.70|  0|  1|    5|    2|\n| 30.4|   4|  95.1| 113| 3.77| 1.513| 16.90|  1|  1|    5|    2|\n| 15.8|   8| 351.0| 264| 4.22| 3.170| 14.50|  0|  1|    5|    4|\n| 19.7|   6| 145.0| 175| 3.62| 2.770| 15.50|  0|  1|    5|    6|\n| 15.0|   8| 301.0| 335| 3.54| 3.570| 14.60|  0|  1|    5|    8|\n| 21.4|   4| 121.0| 109| 4.11| 2.780| 18.60|  1|  1|    4|    2|\n\n</div>\n:::\n:::\n\n\nNotice that this doesn't load the data—it just creates a reference. The data stays in the database.\n\n### Lazy Evaluation\n\ndbplyr operations are **lazy**: they build up a query without executing it until you explicitly request the data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Build a query (doesn't execute yet)\nefficient_cars <- mtcars_db |>\n  filter(mpg > 25) |>\n  select(mpg, cyl, hp, wt) |>\n  arrange(desc(mpg))\n\n# See the generated SQL\nefficient_cars |> show_query()\n#> <SQL>\n#> SELECT mpg, cyl, hp, wt\n#> FROM mtcars\n#> WHERE (mpg > 25.0)\n#> ORDER BY mpg DESC\n```\n:::\n\n\n### Collecting Results\n\nUse `collect()` to execute the query and bring results into R:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Execute query and return results to R\nefficient_cars |> collect()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|  mpg| cyl|  hp|    wt|\n|----:|---:|---:|-----:|\n| 33.9|   4|  65| 1.835|\n| 32.4|   4|  66| 2.200|\n| 30.4|   4|  52| 1.615|\n| 30.4|   4| 113| 1.513|\n| 27.3|   4|  66| 1.935|\n| 26.0|   4|  91| 2.140|\n\n</div>\n:::\n:::\n\n\n::: {.callout-important}\nOnly `collect()` what you need! Fetching an entire large table defeats the purpose of using a database. Filter and aggregate in the database first, then collect the summarized results.\n:::\n\n## Translating dplyr to SQL {#sec-dplyr-sql}\n\ndbplyr translates dplyr verbs to SQL clauses. Let's see how common operations map:\n\n### Filtering and Selecting\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  filter(cyl == 6, mpg > 18) |>\n  select(mpg, cyl, hp, wt) |>\n  show_query()\n#> <SQL>\n#> SELECT mpg, cyl, hp, wt\n#> FROM mtcars\n#> WHERE (cyl = 6.0) AND (mpg > 18.0)\n```\n:::\n\n\n### Mutating (Creating New Columns)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  mutate(\n    efficiency = mpg / wt,\n    hp_per_cyl = hp / cyl\n  ) |>\n  select(mpg, wt, efficiency, hp_per_cyl) |>\n  show_query()\n#> <SQL>\n#> SELECT mpg, wt, mpg / wt AS efficiency, hp / cyl AS hp_per_cyl\n#> FROM mtcars\n```\n:::\n\n\n### Grouping and Summarizing\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  group_by(cyl) |>\n  summarize(\n    n = n(),\n    avg_mpg = mean(mpg, na.rm = TRUE),\n    max_hp = max(hp, na.rm = TRUE)\n  ) |>\n  show_query()\n#> <SQL>\n#> SELECT cyl, COUNT(*) AS n, AVG(mpg) AS avg_mpg, MAX(hp) AS max_hp\n#> FROM mtcars\n#> GROUP BY cyl\n```\n:::\n\n\n### Arranging (Sorting)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  arrange(cyl, desc(mpg)) |>\n  show_query()\n#> <SQL>\n#> SELECT mtcars.*\n#> FROM mtcars\n#> ORDER BY cyl, mpg DESC\n```\n:::\n\n\n## SQL Syntax Details {#sec-sql-syntax}\n\nUnderstanding SQL helps you write better dbplyr code and debug issues.\n\n### Key Differences from R\n\n| Aspect | R/dplyr | SQL |\n|:-------|:--------|:----|\n| Equality | `==` | `=` |\n| Logical AND | `&` | `AND` |\n| Logical OR | `|` | `OR` |\n| Missing values | `NA` | `NULL` |\n| Strings | `\"text\"` or `'text'` | `'text'` only |\n| Case sensitivity | Case sensitive | Keywords case insensitive |\n\n: Syntax differences between R and SQL {#tbl-r-sql-syntax}\n\n### NULL Handling\n\nSQL's `NULL` behaves like R's `NA`—it's \"contagious\" in calculations:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  filter(!is.na(mpg)) |>\n  show_query()\n#> <SQL>\n#> SELECT mtcars.*\n#> FROM mtcars\n#> WHERE (NOT((mpg IS NULL)))\n```\n:::\n\n\n### Subqueries\n\nSometimes dbplyr generates subqueries—queries nested inside other queries:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  mutate(mpg_group = if_else(mpg > 20, \"high\", \"low\")) |>\n  filter(mpg_group == \"high\") |>\n  show_query()\n#> <SQL>\n#> SELECT q01.*\n#> FROM (\n#>   SELECT\n#>     mtcars.*,\n#>     CASE WHEN (mpg > 20.0) THEN 'high' WHEN NOT (mpg > 20.0) THEN 'low' END AS mpg_group\n#>   FROM mtcars\n#> ) q01\n#> WHERE (mpg_group = 'high')\n```\n:::\n\n\nThe subquery is needed because SQL evaluates `WHERE` before `SELECT`, so you can't filter on a column you're creating in the same query.\n\n## Working with Multiple Tables {#sec-db-multiple-tables}\n\nDatabases often store data across multiple related tables (normalized data). You can use joins in dbplyr just like with regular data frames:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Join tables in the database\norders_db |>\n  left_join(customers_db, by = \"customer_id\") |>\n  show_query()\n```\n:::\n\n\nThe join is executed in the database, which is much more efficient than loading both tables into R and joining there.\n\n## Window Functions {#sec-window-functions}\n\nSQL window functions perform calculations across sets of rows related to the current row. dbplyr translates functions like `lag()`, `lead()`, and `rank()` to their SQL equivalents:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars_db |>\n  group_by(cyl) |>\n  mutate(\n    rank_mpg = min_rank(desc(mpg)),\n    mpg_vs_avg = mpg - mean(mpg, na.rm = TRUE)\n  ) |>\n  select(cyl, mpg, rank_mpg, mpg_vs_avg) |>\n  show_query()\n#> <SQL>\n#> SELECT\n#>   cyl,\n#>   mpg,\n#>   CASE\n#> WHEN (NOT((mpg IS NULL))) THEN RANK() OVER (PARTITION BY cyl, (CASE WHEN ((mpg IS NULL)) THEN 1 ELSE 0 END) ORDER BY mpg DESC)\n#> END AS rank_mpg,\n#>   mpg - AVG(mpg) OVER (PARTITION BY cyl) AS mpg_vs_avg\n#> FROM mtcars\n```\n:::\n\n\n## Best Practices {#sec-db-best-practices}\n\n### 1. Filter Early\n\nPush filtering to the database rather than collecting all data and filtering in R:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Good: Filter in database\nmtcars_db |>\n  filter(mpg > 25) |>\n  collect()\n\n# Bad: Collect everything then filter\nmtcars_db |>\n  collect() |>\n  filter(mpg > 25)\n```\n:::\n\n\n### 2. Select Only Needed Columns\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Good: Select specific columns\nmtcars_db |>\n  select(mpg, cyl, hp) |>\n  collect()\n\n# Bad: Collect all columns\nmtcars_db |>\n  collect() |>\n  select(mpg, cyl, hp)\n```\n:::\n\n\n### 3. Aggregate in the Database\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Good: Summarize in database\nmtcars_db |>\n  group_by(cyl) |>\n  summarize(avg_mpg = mean(mpg)) |>\n  collect()\n\n# Bad: Collect then summarize\nmtcars_db |>\n  collect() |>\n  group_by(cyl) |>\n  summarize(avg_mpg = mean(mpg))\n```\n:::\n\n\n### 4. Close Connections\n\nAlways close your database connection when you're done:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n\n\n## When to Use Databases {#sec-when-databases}\n\nDatabases are valuable when:\n\n- **Data is too large for memory**: Even modest databases handle billions of rows\n- **Multiple users need access**: Databases manage concurrent access safely\n- **Data changes frequently**: Updates are immediate, no file copying needed\n- **You need specific subsets**: Queries return just what you need\n- **Data integrity matters**: Constraints prevent invalid data\n\nFor smaller datasets that fit comfortably in memory, regular data frames are simpler and faster for exploratory analysis.\n\n## Summary {#sec-db-summary}\n\nIn this chapter, you learned how to:\n\n- Connect to databases from R using DBI\n- Use duckdb as a lightweight analytical database\n- Write basic SQL queries with SELECT, WHERE, and GROUP BY\n- Use dbplyr to work with databases using familiar dplyr syntax\n- Translate dplyr operations to SQL and understand the generated queries\n- Apply best practices for efficient database access\n\nThe combination of dbplyr and DBI lets you leverage your existing tidyverse skills while accessing data at any scale. When you need to work with data too large for memory or collaborate with others through a shared database, these tools let you stay productive without learning an entirely new programming paradigm.\n\n## Exercises {.unnumbered}\n\n1. **Basic Connection**: Connect to a duckdb database and load the `nycflights13::flights` data into a table called \"flights\".\n\n2. **SQL Practice**: Write SQL queries to:\n   - Find all flights from JFK airport\n   - Calculate the average departure delay by carrier\n   - Find the 10 destinations with the most flights\n\n3. **dbplyr Translation**: Use dbplyr to write the equivalent dplyr code for each SQL query above. Compare the generated SQL with your hand-written queries.\n\n4. **Efficient Querying**: Given a database with a large \"sales\" table:\n   - What's wrong with: `tbl(con, \"sales\") |> collect() |> filter(year == 2023)`?\n   - How would you rewrite this query efficiently?\n\n5. **Joins in Databases**: If you have two tables, \"experiments\" and \"samples\", linked by sample_id:\n   - Write dbplyr code to join them\n   - Use `show_query()` to see the generated SQL\n   - Explain when the join happens (in R or in the database)\n\n## Additional Resources {.unnumbered}\n\n- [DBI package documentation](https://dbi.r-dbi.org/)\n- [dbplyr package documentation](https://dbplyr.tidyverse.org/)\n- [duckdb for R](https://duckdb.org/docs/api/r)\n- [SQL for Data Scientists](https://sqlfordatascientists.com) by Renée M. P. Teate\n- [Practical SQL](https://www.practicalsql.com) by Anthony DeBarros\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}