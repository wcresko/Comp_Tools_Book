# Unix Fundamentals {#sec-unix-fundamentals}

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(gt)
theme_set(theme_minimal())
```

::: {.callout-note title="Learning Objectives"}
After completing this chapter, you will be able to:

- Explain what Unix is and why it's important for scientific computing
- Access the shell on your operating system
- Navigate the file system using command-line tools
- Understand the anatomy of shell commands
- Create, move, copy, and delete files and directories
:::

## What Is Unix?

**Unix** is a family of operating systems originally developed at Bell Labs in 1969 and publicly released in 1973 [@kernighan1984unix]. What began as a project for a single computer has become the foundation of modern computing infrastructure.

Today, Unix and its derivatives power:

- Most web servers on the internet
- Scientific computing clusters (including Talapas)
- macOS (Apple's desktop operating system)
- Android phones (via the Linux kernel)
- Embedded systems in everything from routers to cars

**Linux** is an open-source implementation of Unix principles that has become the dominant operating system for scientific computing. When we refer to "Unix commands" in this book, the same commands work on Linux, macOS, and Windows Subsystem for Linux (WSL).

::: {.callout-tip}
Learning Unix is an investment that pays dividends throughout your career. The commands you learn today will work on systems you encounter decades from now—Unix's longevity is remarkable in the fast-changing world of technology.
:::

## The Shell: Your Interface to Unix

The **shell** is a program that interprets your commands and communicates with the operating system. Think of it as a translator between human-readable instructions and the computer's internal operations.

While graphical user interfaces (GUIs) like Finder on Mac or File Explorer on Windows are intuitive for casual use, the shell offers:

- **Speed**: Type commands faster than clicking through menus
- **Power**: Access to thousands of specialized tools
- **Automation**: Script repetitive tasks
- **Remote Access**: Work on distant computers identically to local ones
- **Reproducibility**: Document exactly what you did

### Bash: The Default Shell

**Bash** (Bourne Again SHell) is the default shell on most Unix systems and is what you'll use throughout this course. Other shells exist (zsh, fish, tcsh), but Bash is the most widely used and what you'll encounter on computing clusters.

### Accessing the Shell

How you access the shell depends on your operating system:

**macOS**
:   Open the **Terminal** application (Applications → Utilities → Terminal) or use a third-party terminal like iTerm2.

**Linux**
:   Open your distribution's terminal application, often called "Terminal" or "Console."

**Windows**
:   After installing WSL (see @sec-windows-setup), search for "Ubuntu" or your installed Linux distribution in the Start menu.

When you open the terminal, you'll see a **prompt** indicating the system is ready for your command:

```bash
username@computer:~$
```

The prompt typically shows your username, the computer name, your current directory (`~` means your home directory), and a `$` symbol indicating you're a regular user (a `#` would indicate administrator/root access).

## Anatomy of a Shell Command

Every shell command follows a consistent structure:

```bash
command -options arguments
```

Let's break this down:

**Command**
:   The program or built-in function you want to run. This is required.

**Options** (also called flags)
:   Modify the command's behavior. Usually preceded by `-` (single letter) or `--` (full word). Optional.

**Arguments**
:   What the command should operate on—typically file or directory names. Sometimes optional.

For example:

```bash
ls -l Documents
```

Here, `ls` is the command (list directory contents), `-l` is an option (use long format with details), and `Documents` is the argument (which directory to list).

::: {.callout-note}
Options can often be combined. For example, `ls -l -h -a` can be written as `ls -lha`. The order of combined options usually doesn't matter.
:::

## Understanding the File System

Unix organizes everything as files within a hierarchical directory structure. Understanding this structure is essential for navigation.

### The Directory Tree

The entire file system branches from a single root directory, represented by `/`:

```
/
├── Users/
│   └── wcresko/
│       ├── Documents/
│       ├── Downloads/
│       └── projects/
├── Applications/
├── Library/
└── tmp/
```

Key directories include:

**`/`**
:   The root directory. Everything else is inside this.

**`/home` or `/Users`**
:   Contains user home directories. Your files live here.

**`~`**
:   Shorthand for your home directory (e.g., `/home/wcresko`).

**`/tmp`**
:   Temporary files that may be deleted on reboot.

### Absolute vs. Relative Paths

A **path** specifies the location of a file or directory. Paths come in two forms:

**Absolute Paths**
:   Start from the root directory (`/`). They work from anywhere because they specify the complete location.
```bash
/Users/wcresko/Documents/analysis.R
```

**Relative Paths**
:   Start from your current directory. Shorter but depend on where you are.
```bash
Documents/analysis.R
```

Special directory references:

- `.` (single dot) — current directory
- `..` (double dot) — parent directory (one level up)
- `~` — your home directory

::: {.callout-tip}
Use Tab completion! Start typing a file or directory name and press Tab to autocomplete. This saves typing and prevents errors.
:::

## Essential Navigation Commands

### Where Am I? `pwd`

The `pwd` command (**p**rint **w**orking **d**irectory) shows your current location:
```bash
$ pwd
/Users/wcresko/projects/analysis
```

Always know where you are before running commands—especially destructive ones!

### What's Here? `ls`

The `ls` command (**l**i**s**t) shows directory contents:

```bash
$ ls
data/  results/  analysis.R  README.md
```

Common options make `ls` more informative:

| Option | Description |
|:-------|:------------|
| `-l` | Long format (permissions, size, date) |
| `-a` | Show hidden files (those starting with `.`) |
| `-h` | Human-readable file sizes (KB, MB, GB) |
| `-t` | Sort by modification time (newest first) |
| `-S` | Sort by file size (largest first) |
| `-r` | Reverse sort order |
| `-F` | Add symbols to show file types (`/` for directories, `*` for executables) |

: Common options for the `ls` command {#tbl-ls-options}

Example with multiple options:
```bash
$ ls -lah
total 32K
drwxr-xr-x  4 wcresko staff 128B Nov 15 14:30 .
drwxr-xr-x 12 wcresko staff 384B Nov 14 09:15 ..
-rw-r--r--  1 wcresko staff 2.1K Nov 15 14:30 analysis.R
drwxr-xr-x  3 wcresko staff  96B Nov 15 10:00 data
-rw-r--r--  1 wcresko staff  512 Nov 14 09:15 README.md
drwxr-xr-x  2 wcresko staff  64B Nov 15 14:00 results
```

The long format shows: permissions, links, owner, group, size, modification date, and name.

### Moving Around: `cd`

The `cd` command (**c**hange **d**irectory) moves you to a different location:

```bash
# Go to a specific directory
$ cd Documents

# Go up one directory
$ cd ..

# Go to home directory (three equivalent ways)
$ cd ~
$ cd $HOME
$ cd

# Go to the previous directory (like "back" in a browser)
$ cd -

# Go to an absolute path
$ cd /Users/wcresko/projects
```

::: {.callout-caution}
Unlike GUIs, `cd` gives no feedback when successful. If you don't see an error message, the command worked! Use `pwd` to verify where you ended up.
:::

## Working with Files and Directories

Now that you can navigate, let's learn to manipulate files and directories.

### Creating Directories: `mkdir`

```bash
# Create a single directory
$ mkdir analysis

# Create nested directories (use -p for parents)
$ mkdir -p project/data/raw

# Create multiple directories at once
$ mkdir results figures tables
```

### Creating Files: `touch` and `nano`

The `touch` command creates an empty file (or updates the timestamp of an existing file):

```bash
$ touch notes.txt
```

For files with content, use a text editor. `nano` is a simple terminal-based editor:

```bash
$ nano notes.txt
```

In nano:
- Type your content normally
- `Ctrl+O` saves the file (press Enter to confirm)
- `Ctrl+X` exits nano

### Copying Files: `cp`

```bash
# Copy a file
$ cp original.txt backup.txt

# Copy a file to a directory
$ cp analysis.R scripts/

# Copy a directory (requires -r for recursive)
$ cp -r data/ data_backup/

# Copy multiple files to a directory
$ cp *.txt documents/
```

### Moving and Renaming: `mv`

The `mv` command both moves and renames files:

```bash
# Rename a file
$ mv oldname.txt newname.txt

# Move a file to a directory
$ mv analysis.R scripts/

# Move and rename simultaneously
$ mv data/raw.csv backup/raw_2024.csv

# Move multiple files
$ mv *.R scripts/
```

### Deleting Files: `rm` and `rmdir`

::: {.callout-warning title="Danger Zone"}
The shell has no trash can! Deleted files are gone forever. Always double-check before using `rm`, especially with wildcards.
:::

```bash
# Remove a file
$ rm unnecessary.txt

# Remove multiple files
$ rm *.tmp

# Remove a directory and all contents (DANGEROUS!)
$ rm -r old_project/

# Interactive mode (asks for confirmation)
$ rm -i important.txt

# Remove empty directories only
$ rmdir empty_folder/
```

The `-r` (recursive) option with `rm` is powerful but dangerous. Consider using `-i` (interactive) to confirm each deletion when learning.

### Viewing Files: `cat`, `head`, `tail`, `less`

```bash
# Display entire file
$ cat README.md

# First 10 lines (or specify -n NUMBER)
$ head data.csv
$ head -n 20 data.csv

# Last 10 lines
$ tail data.csv
$ tail -n 5 data.csv

# Follow a file as it grows (great for logs)
$ tail -f analysis.log

# Page through a large file
$ less huge_data.txt
```

In `less`:
- Space or `f` — next page
- `b` — previous page
- `/pattern` — search forward
- `n` — next search result
- `q` — quit

### File Information: `wc`

The `wc` (**w**ord **c**ount) command provides file statistics:

```bash
$ wc document.txt
  100   850  5420 document.txt
```

This shows: lines, words, and bytes. Useful options:

```bash
$ wc -l data.csv   # Lines only
$ wc -w essay.txt  # Words only
$ wc -c file.bin   # Bytes only
```

## Naming Conventions

Good naming practices prevent countless problems:

::: {.callout-important title="File Naming Rules"}
**DO:**
- Use lowercase letters, numbers, underscores (`_`), and hyphens (`-`)
- Use meaningful, descriptive names
- Include dates in ISO format if relevant: `data_2024-01-15.csv`
- Use appropriate file extensions

**DON'T:**
- Use spaces (use `_` or `-` instead)
- Start names with `-` (confused with options)
- Use special characters: `* ? [ ] ' " \ / < > |`
- Use extremely long names
:::

Examples:

| Bad | Good |
|:----|:-----|
| `my data.csv` | `my_data.csv` |
| `-results.txt` | `results.txt` |
| `data (copy).csv` | `data_copy.csv` |
| `Joe's file.txt` | `joes_file.txt` |

## Getting Help

### Manual Pages

Every Unix command has a manual page accessible via `man`:

```bash
$ man ls
```

Manual pages can be dense. Look for:
- **NAME**: What the command does
- **SYNOPSIS**: How to use it
- **DESCRIPTION**: Detailed explanation
- **OPTIONS**: Available flags
- **EXAMPLES**: If you're lucky!

Press `q` to exit the manual.

### Quick Help

Many commands support a `--help` option:

```bash
$ ls --help
```

### Searching for Commands

If you know what you want to do but not the command:

```bash
# Search man page descriptions
$ man -k "search term"
$ apropos "search term"

# Find where a command is located
$ which python
```

## Summary

This chapter covered the fundamentals of Unix navigation and file manipulation:

- The shell interprets commands and interfaces with the operating system
- Commands follow the pattern: `command -options arguments`
- The file system is a hierarchical tree starting at `/`
- Navigation uses `pwd`, `ls`, and `cd`
- File operations include `cp`, `mv`, `rm`, `mkdir`, and `touch`
- Good naming conventions prevent problems
- Manual pages (`man`) provide detailed help

These commands form the foundation for everything else in Unix. Practice them until they become automatic!

## Exercises {.unnumbered}

::: {.callout-tip title="Practice Exercises"}
**Exercise 1: Navigation Practice**

Without using a GUI file browser:

1. Open your terminal
2. Print your current directory
3. Navigate to your home directory
4. List all files including hidden ones
5. Navigate to your Documents folder (or create it if needed)
6. Return to your home directory using the shortcut

**Exercise 2: File Operations**

1. Create a new directory called `practice`
2. Navigate into it
3. Create an empty file called `notes.txt`
4. Create a subdirectory called `backup`
5. Copy `notes.txt` to the `backup` directory
6. Rename the original `notes.txt` to `my_notes.txt`
7. List the contents of both directories to verify your work
8. Clean up by removing the entire `practice` directory

**Exercise 3: Exploration**

Use manual pages to answer:

1. What does the `ls -R` option do?
2. How can you create a directory and all necessary parent directories in one command?
3. What command shows disk usage, and what option makes the output human-readable?
:::
