# GREP and Regular Expressions {#sec-grep-regex}

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(gt)
theme_set(theme_minimal())
```

::: {.callout-note title="Learning Objectives"}
After completing this chapter, you will be able to:

- Use `grep` to search for patterns in files and data streams
- Construct regular expressions to match complex patterns
- Apply extended regular expressions for advanced pattern matching
- Combine `grep` with other Unix tools for sophisticated text processing
- Search genomic data for biological patterns like restriction sites and motifs
:::

## Introduction to Pattern Matching {#sec-pattern-matching}

While the tools in @sec-files-pipes can filter and transform data, they work on whole lines or fixed positions. **Pattern matching** lets you search based on the *content* of text—finding lines that contain specific sequences of characters.

**GREP** (**G**lobal **R**egular **E**xpression **P**rint) is the Unix standard for pattern matching. Originally developed for the ed text editor in the 1970s, `grep` remains essential for bioinformatics, log analysis, and text processing.

## Basic GREP Usage {#sec-basic-grep}

At its simplest, `grep` finds lines containing a specific string:

```bash
# Find lines containing "error"
$ grep "error" logfile.txt

# Search multiple files
$ grep "mutation" *.txt

# Search recursively in directories
$ grep -r "BRCA1" data/
```

### Essential GREP Options

| Option | Description |
|:-------|:------------|
| `-i` | Case-insensitive search |
| `-v` | Invert match (lines NOT containing pattern) |
| `-c` | Count matching lines |
| `-n` | Show line numbers |
| `-l` | List only filenames with matches |
| `-o` | Print only the matched part |
| `-w` | Match whole words only |
| `-A n` | Show n lines after match |
| `-B n` | Show n lines before match |
| `-C n` | Show n lines before and after match |

: Common `grep` options {#tbl-grep-options}

### Examples

```bash
# Case-insensitive search
$ grep -i "gene" annotations.txt

# Count matches (not lines, just the count)
$ grep -c ">" sequences.fasta

# Show line numbers
$ grep -n "ERROR" application.log

# Find files containing pattern
$ grep -l "experimental" *.md

# Remove comment lines (inverted match)
$ grep -v "^#" config.txt

# Show context around matches
$ grep -C 2 "significant" results.txt
```

## Introduction to Regular Expressions {#sec-regex-intro}

So far we've searched for literal text. **Regular expressions** (regex) let you describe patterns that match multiple strings.

For example, the pattern `[ACGT]+` matches any sequence of DNA bases, while `colou?r` matches both "color" and "colour".

### Metacharacters: Characters with Special Meaning

Regular expressions use certain characters as pattern-building blocks:

| Character | Meaning | Example |
|:----------|:--------|:--------|
| `.` | Any single character | `a.c` matches "abc", "a1c", "a-c" |
| `*` | Zero or more of preceding | `ab*c` matches "ac", "abc", "abbc" |
| `^` | Start of line | `^Hello` matches lines starting with "Hello" |
| `$` | End of line | `end$` matches lines ending with "end" |
| `[]` | Character class | `[aeiou]` matches any vowel |
| `[^]` | Negated class | `[^0-9]` matches non-digits |
| `\` | Escape special characters | `\.` matches literal period |

: Basic regular expression metacharacters {#tbl-regex-basic}

::: {.callout-note}
The `*` in regular expressions is different from the `*` wildcard in the shell. In regex, `*` means "zero or more of the preceding character." In shell globbing, `*` means "any characters."
:::

### Anchors: Position Matching

Anchors don't match characters—they match positions:

```bash
# Lines starting with "Chr"
$ grep "^Chr" genome.gff

# Lines ending with "protein"
$ grep "protein$" annotations.txt

# Empty lines
$ grep "^$" file.txt

# Lines with exactly "gene"
$ grep "^gene$" list.txt
```

### Character Classes

Character classes match any single character from a set:

```bash
# Match any vowel
$ grep "[aeiou]" words.txt

# Match any digit
$ grep "[0-9]" data.txt

# Match any uppercase letter
$ grep "[A-Z]" text.txt

# Match DNA bases
$ grep "[ACGT]" sequence.txt

# Match non-DNA characters (errors in sequence)
$ grep "[^ACGTN]" sequence.txt
```

**Predefined character classes:**

- `[[:alpha:]]` — letters
- `[[:digit:]]` — digits (same as `[0-9]`)
- `[[:alnum:]]` — letters and digits
- `[[:space:]]` — whitespace
- `[[:upper:]]` — uppercase letters
- `[[:lower:]]` — lowercase letters

### Quantifiers

Quantifiers specify how many times a pattern should repeat:

```bash
# Match "color" or "colour" (zero or one 'u')
$ grep "colou\?r" text.txt

# Three consecutive A's
$ grep "A\{3\}" sequence.txt

# Two to four T's
$ grep "T\{2,4\}" sequence.txt

# At least three G's
$ grep "G\{3,\}" sequence.txt
```

::: {.callout-warning}
In basic `grep`, quantifiers like `?`, `+`, and `{}` must be escaped with `\`. Use `grep -E` or `egrep` to avoid escaping.
:::

## Extended Regular Expressions {#sec-extended-regex}

Extended regular expressions (ERE) add more metacharacters and don't require escaping common quantifiers. Use `grep -E` or `egrep`:

| Character | Meaning |
|:----------|:--------|
| `+` | One or more of preceding |
| `?` | Zero or one of preceding |
| `{n}` | Exactly n of preceding |
| `{n,m}` | Between n and m of preceding |
| `\|` | Alternation (OR) |
| `()` | Grouping |

: Extended regular expression metacharacters {#tbl-regex-extended}

### Alternation: Matching Multiple Patterns

```bash
# Match "start" OR "stop" OR "pause"
$ grep -E "start|stop|pause" commands.txt

# Match any start codon
$ grep -E "ATG|GTG|TTG" sequences.fa

# Match file extensions
$ grep -E "\.(txt|csv|tsv)$" filelist.txt
```

### Grouping

Parentheses group patterns together:

```bash
# Match "gray" or "grey"
$ grep -E "gr(a|e)y" text.txt

# Match "ab", "abab", "ababab", etc.
$ grep -E "(ab)+" data.txt

# Match repeated dinucleotide
$ grep -E "(AT){3,}" sequence.txt
```

### The Plus Quantifier

Unlike `*` (zero or more), `+` requires at least one match:

```bash
# One or more A's followed by one or more T's
$ grep -E "A+T+" sequence.txt

# One or more digits
$ grep -E "[0-9]+" data.txt
```

## Practical Bioinformatics Examples {#sec-regex-bioinformatics}

### Working with FASTA Files

```bash
# Count sequences (lines starting with >)
$ grep -c "^>" sequences.fa

# Extract all headers
$ grep "^>" sequences.fa

# Find specific gene headers
$ grep -i "kinase" sequences.fa

# Find sequences by organism
$ grep -E "^>.*Homo sapiens" proteins.fa
```

### Searching for Biological Motifs

```bash
# Find restriction enzyme sites
$ grep -E "GAATTC" genome.fa         # EcoRI
$ grep -E "GGATCC" genome.fa         # BamHI
$ grep -E "G[ACGT]ANTC" genome.fa    # Degenerate site

# Find potential ORFs (start followed by bases, then stop)
$ grep -oE "ATG([ACGT]{3})*?(TAA|TAG|TGA)" cds.fa

# Find poly-A tails
$ grep -E "A{10,}" transcripts.fa

# Find microsatellites (dinucleotide repeats)
$ grep -E "(AT){5,}" genome.fa
$ grep -E "(CA){5,}" genome.fa
```

### Analyzing GFF/GTF Files

```bash
# Find all genes
$ grep -P "\tgene\t" annotations.gff

# Find genes on chromosome 1
$ grep "^chr1" genes.gff | grep -P "\tgene\t"

# Extract gene IDs
$ grep -oE "gene_id \"[^\"]+\"" annotations.gtf

# Find protein-coding genes
$ grep "protein_coding" annotations.gtf
```

### Log File Analysis

```bash
# Find errors in logs
$ grep -i "error" application.log

# Find specific error codes
$ grep -E "error\s*[0-9]{3}" application.log

# Extract timestamps of errors
$ grep -E "^[0-9]{4}-[0-9]{2}-[0-9]{2}.*error" log.txt

# Count errors per type
$ grep -oE "ERROR: [A-Za-z]+" log.txt | sort | uniq -c
```

## Combining GREP with Pipes {#sec-grep-pipes}

The real power of `grep` emerges when combined with other tools:

```bash
# Count unique patterns
$ grep "^>" sequences.fa | sort | uniq | wc -l

# Extract sequence names without > symbol
$ grep "^>" sequences.fa | cut -c2-

# Find headers, then get organism names
$ grep "^>" proteins.fa | grep -oE "\[.*\]" | sort | uniq -c | sort -rn

# Process FASTA: count bases per sequence
$ grep -v "^>" sequence.fa | while read line; do
    echo "$line" | wc -c
  done
```

### Extracting Matching Regions

The `-o` flag prints only the matched portion:

```bash
# Extract all email addresses
$ grep -oE "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}" contacts.txt

# Extract all URLs
$ grep -oE "https?://[a-zA-Z0-9./?=_-]+" webpage.html

# Extract gene names from headers
$ grep "^>" genes.fa | grep -oE "gene=[^;]+"
```

### Context Searches

When you need to see what surrounds a match:

```bash
# Show 3 lines after each match (including the sequence)
$ grep -A 3 "^>interesting_gene" sequences.fa

# Show lines before and after
$ grep -C 5 "error" logfile.txt

# Extract sequence following a header
$ grep -A 1 "^>target_gene" sequences.fa | grep -v "^>"
```

## Processing Genomic Data: A Complete Example {#sec-genomic-processing}

Let's work through a realistic analysis pipeline for human chromosome data.

### Downloading the Data

```bash
# Download human chromosome 21 (smaller for practice)
$ wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/405/\
GCF_000001405.40_GRCh38.p14/GCF_000001405.40_GRCh38.p14_genomic.fna.gz

# Or work with a subset
$ zcat genome.fa.gz | head -1000 > sample.fa
```

### Analyzing Sequence Content

```bash
# Count sequences in the file
$ grep -c "^>" genome.fa

# View headers
$ grep "^>" genome.fa | head

# Total bases (excluding headers and newlines)
$ grep -v "^>" genome.fa | tr -d '\n' | wc -c

# Nucleotide frequencies
$ grep -v "^>" genome.fa | tr -d '\n' | fold -w1 | sort | uniq -c
```

### Finding Restriction Enzyme Sites

```bash
# Count EcoRI sites (GAATTC)
$ grep -v "^>" genome.fa | tr -d '\n' | grep -o "GAATTC" | wc -l

# Count multiple restriction sites
$ for site in GAATTC GGATCC AAGCTT CTCGAG; do
    count=$(grep -v "^>" genome.fa | tr -d '\n' | grep -o "$site" | wc -l)
    echo "$site: $count"
  done

# Find context around restriction sites (50 bases each side)
$ grep -v "^>" genome.fa | tr -d '\n' | grep -oE ".{50}GAATTC.{50}" | head
```

### Finding Simple Sequence Repeats

```bash
# Dinucleotide repeats
$ grep -v "^>" genome.fa | tr -d '\n' | grep -oE "(AT){5,}" | wc -l
$ grep -v "^>" genome.fa | tr -d '\n' | grep -oE "(CA){5,}" | wc -l

# Homopolymer runs (consecutive same base)
$ grep -v "^>" genome.fa | tr -d '\n' | grep -oE "A{10,}" | wc -l
$ grep -v "^>" genome.fa | tr -d '\n' | grep -oE "T{10,}" | wc -l
```

### Stream Processing Large Files

Process data without loading it entirely into memory:

```bash
# Download, decompress, and analyze in one pipeline
$ curl -s ftp://example.com/genome.fa.gz | \
  gunzip -c | \
  grep -v "^>" | \
  tr -d '\n' | \
  grep -o "GAATTC" | \
  wc -l

# Process compressed file directly
$ zgrep -c "^>" genome.fa.gz
```

## Common Patterns Reference {#sec-common-patterns}

Here's a quick reference for frequently needed patterns:

| Pattern | What It Matches |
|:--------|:----------------|
| `^>` | FASTA headers |
| `^#` | Comment lines |
| `^$` | Empty lines |
| `[ACGT]+` | DNA sequence |
| `[ACGU]+` | RNA sequence |
| `[A-Z]{3}` | Uppercase triplet (codon) |
| `ATG([ACGT]{3})*` | Potential ORF |
| `(TAA\|TAG\|TGA)` | Stop codons |
| `A{n,}` | Poly-A of at least n |
| `\t` | Tab character |
| `\s+` | One or more whitespace |
| `[0-9]+\.[0-9]+` | Decimal number |

: Common regular expression patterns for bioinformatics {#tbl-common-patterns}

## Summary {#sec-regex-summary}

This chapter covered pattern matching with `grep` and regular expressions:

- `grep` finds lines matching patterns in files or streams
- Basic regex uses metacharacters: `.`, `*`, `^`, `$`, `[]`
- Extended regex (`grep -E`) adds: `+`, `?`, `|`, `{}`
- Character classes match sets of characters
- Anchors match positions (start/end of line)
- Combining `grep` with pipes enables powerful analysis
- Genomic data analysis uses these tools for motif searching

Regular expressions are a foundational skill. While the syntax can seem cryptic initially, investment in learning regex pays off enormously across all aspects of computational biology.

::: {.callout-tip}
For a comprehensive reference of regular expression patterns and `grep` command syntax, see @sec-appendix-regex. For other Unix commands, see @sec-appendix-unix.
:::

## Additional Reading {.unnumbered}

To deepen your understanding of regular expressions:

- **[Regular-Expressions.info](https://www.regular-expressions.info/)** — A comprehensive tutorial and reference site for regex
- **[RegexOne](https://regexone.com/)** — An interactive tutorial for learning regular expressions step by step
- **[regex101.com](https://regex101.com/)** — An online regex tester with explanations of each component
- **"Mastering Regular Expressions"** by Jeffrey Friedl — The definitive book on regex theory and practice

For bioinformatics-specific pattern matching:

- **[BioStars: Regular Expressions in Bioinformatics](https://www.biostars.org/)** — Community Q&A with many regex examples
- **[Rosalind.info](http://rosalind.info/)** — Bioinformatics problem sets that often require regex solutions
- **GNU Grep Manual** — Official documentation with advanced options: `man grep` or online at [gnu.org](https://www.gnu.org/software/grep/manual/)

## Exercises {.unnumbered}

::: {.callout-tip title="Practice Exercises"}
**Exercise 1: Basic Pattern Matching**

Create a file with various text and practice:
1. Find all lines containing "the" (case-insensitive)
2. Find lines starting with a capital letter
3. Find lines ending with a period
4. Count empty lines

**Exercise 2: Biological Patterns**

Using a FASTA file:
1. Count the number of sequences
2. Extract headers for sequences longer than 1000 bp (hint: you'll need multiple commands)
3. Find all sequences containing the pattern "TATAAA" (TATA box)
4. Count how many sequences have "chromosome" in their header

**Exercise 3: Regular Expression Practice**

Write `grep` commands to match:
1. Phone numbers in format: (555) 555-5555
2. Email addresses
3. Dates in YYYY-MM-DD format
4. DNA sequences that are exactly 20 bases long

**Exercise 4: Genomic Analysis Pipeline**

Download a bacterial genome and:
1. Calculate the genome size
2. Count all restriction sites for at least 3 different enzymes
3. Find the longest homopolymer run
4. Calculate GC content using only Unix tools
5. Document your pipeline in a shell script
:::
