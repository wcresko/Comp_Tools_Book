# Writing Functions in R {#sec-writing-functions}

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(data.table)
theme_set(theme_minimal())
```

::: {.callout-note title="Learning Objectives"}
After completing this chapter, you will be able to:

- Write your own R functions using proper syntax
- Specify function arguments with default values
- Return single or multiple values from functions
- Use control flow (if/else, case_when) within functions
- Understand lexical scoping and function environments
- Apply functional programming principles with lapply and purrr
- Iterate over single and multiple inputs efficiently
- Choose between for loops and functional approaches
:::

## Why Write Your Own Functions? {#sec-why-functions}

Throughout this book, we've used many functions: some from base R (like `mean()` and `sum()`), others from packages (like `dplyr::filter()` and `ggplot2::ggplot()`). But the real power of programming comes from writing your own functions.

Functions allow you to:

- **Avoid repetition**: Write code once, use it many times
- **Reduce errors**: Fix bugs in one place rather than many
- **Improve readability**: Give meaningful names to complex operations
- **Share code**: Package your solutions for others to use

In biosciences, you'll often need custom functions for tasks like:

- Calculating enzyme kinetics parameters
- Normalizing gene expression data
- Computing population genetics statistics
- Processing experimental replicates

## Basic Function Syntax {#sec-function-syntax}

All R functions follow the same basic syntax:

```r
function_name = function(ARGUMENTS) {
  OPERATIONS
  return(VALUE)
}
```

Let's break this down:

- **function_name**: A descriptive name for your function
- **ARGUMENTS**: Input values the function accepts
- **OPERATIONS**: What the function does
- **return(VALUE)**: What the function gives back

For short functions, you can write everything on one line:

```r
my_short_func = function(x) x^2
```

::: {.callout-tip}
Give your functions short, descriptive names that indicate what they do. `calculate_gc_content` is better than `func1` or `cgc`.
:::

## A Simple Example: GC Content Calculator {#sec-gc-example}

Let's write a function that calculates the GC content of a DNA sequence --- the proportion of guanine (G) and cytosine (C) bases.

```{r}
#| label: gc-content-basic

gc_content = function(sequence) {
  # Convert to uppercase for consistency
  seq_upper = toupper(sequence)

  # Count G and C bases
  gc_count = str_count(seq_upper, "[GC]")

  # Calculate total length (excluding any non-ATGC characters)
  total_bases = str_count(seq_upper, "[ATGC]")

  # Return GC proportion
  gc_count / total_bases
}
```

Test it:

```{r}
#| label: gc-test

gc_content("ATGCGATCGATCG")
gc_content("atgcGATCgatcg")  # Works with mixed case
gc_content("AAAAAATTTTTT")   # Low GC content
gc_content("GGGGGGCCCCCC")   # High GC content
```

### Specifying Return Values

In the example above, R automatically returned the last evaluated expression. However, it's good practice to use explicit `return()` statements, especially for complex functions:

```{r}
#| label: gc-content-explicit

gc_content = function(sequence) {
  seq_upper = toupper(sequence)
  gc_count = str_count(seq_upper, "[GC]")
  total_bases = str_count(seq_upper, "[ATGC]")
  gc_proportion = gc_count / total_bases

  return(gc_proportion)  # Explicit return
}
```

### Returning Multiple Values

What if we want to return more than one piece of information? Use a list or data frame:

```{r}
#| label: gc-content-detailed

gc_content_detailed = function(sequence) {
  seq_upper = toupper(sequence)

  # Count each base
  a_count = str_count(seq_upper, "A")
  t_count = str_count(seq_upper, "T")
  g_count = str_count(seq_upper, "G")
  c_count = str_count(seq_upper, "C")

  total = a_count + t_count + g_count + c_count
  gc_prop = (g_count + c_count) / total

  # Return as a data frame
  result = tibble(
    sequence = sequence,
    length = total,
    A = a_count,
    T = t_count,
    G = g_count,
    C = c_count,
    gc_content = round(gc_prop, 4)
  )

  return(result)
}

gc_content_detailed("ATGCGATCGATCGATCG")
```

### Default Argument Values

You can specify default values for arguments. This is useful when most calls will use the same value:

```{r}
#| label: gc-with-defaults

gc_content = function(sequence, digits = 4) {
  seq_upper = toupper(sequence)
  gc_count = str_count(seq_upper, "[GC]")
  total_bases = str_count(seq_upper, "[ATGC]")
  gc_proportion = gc_count / total_bases

  return(round(gc_proportion, digits))
}

gc_content("ATGCGATCGATCG")       # Uses default 4 digits
gc_content("ATGCGATCGATCG", 2)    # Override to 2 digits
```

## Environments and Lexical Scoping {#sec-lexical-scoping}

An important concept to understand is that functions operate in their own **environment**. Objects created inside a function don't appear in your global environment:

```{r}
#| label: scoping-demo

test_function = function(x) {
  internal_var = x * 2  # This stays inside the function
  return(internal_var)
}

result = test_function(5)
result

# Try to access internal_var - it doesn't exist in the global environment
# internal_var  # Would produce an error
```

This is called **lexical scoping**. R looks for objects in this order:

1. Inside the function
2. In the environment where the function was defined
3. In parent environments, up to the global environment

::: {.callout-important}
Functions are "sandboxed" --- they don't pollute your global environment with intermediate variables. This makes code cleaner and reduces the risk of naming conflicts.
:::

## Control Flow in Functions {#sec-control-flow}

### Using if/else

Control flow allows your functions to behave differently based on conditions:

```{r}
#| label: enzyme-kinetics

# Calculate enzyme velocity using Michaelis-Menten kinetics
enzyme_velocity = function(substrate, vmax, km, inhibitor = NULL, ki = NULL) {

  if (is.null(inhibitor)) {
    # No inhibitor: standard Michaelis-Menten
    velocity = (vmax * substrate) / (km + substrate)
  } else {
    # Competitive inhibition
    if (is.null(ki)) {
      stop("If inhibitor concentration is provided, ki must also be specified")
    }
    apparent_km = km * (1 + inhibitor / ki)
    velocity = (vmax * substrate) / (apparent_km + substrate)
  }

  return(velocity)
}

# Test without inhibitor
enzyme_velocity(substrate = 10, vmax = 100, km = 5)

# Test with inhibitor
enzyme_velocity(substrate = 10, vmax = 100, km = 5, inhibitor = 2, ki = 3)
```

### Using case_when for Multiple Conditions

When you have many conditions, nested `if/else` statements become hard to read. Use `dplyr::case_when()` instead:

```{r}
#| label: classify-expression

# Classify gene expression fold changes
classify_expression = function(fold_change) {
  category = case_when(
    fold_change >= 2 ~ "strongly_upregulated",
    fold_change >= 1.5 ~ "upregulated",
    fold_change <= 0.5 ~ "strongly_downregulated",
    fold_change <= 0.67 ~ "downregulated",
    TRUE ~ "unchanged"
  )
  return(category)
}

# Test with a vector of fold changes
fold_changes = c(0.3, 0.6, 1.0, 1.6, 2.5)
classify_expression(fold_changes)
```

The equivalent `data.table::fcase()` function works similarly:

```{r}
#| label: classify-expression-dt

classify_expression_dt = function(fold_change) {
  fcase(
    fold_change >= 2, "strongly_upregulated",
    fold_change >= 1.5, "upregulated",
    fold_change <= 0.5, "strongly_downregulated",
    fold_change <= 0.67, "downregulated",
    default = "unchanged"
  )
}

classify_expression_dt(fold_changes)
```

## Iteration and Functional Programming {#sec-iteration}

### The Problem with for Loops

You'll often need to apply the same operation to many inputs. The traditional approach uses `for` loops:

```{r}
#| label: for-loop-example

# Calculate GC content for multiple sequences
sequences = c("ATGCGATCG", "GGGGCCCC", "AAAATTTT", "ATATATAT")

# Using a for loop
gc_results = NULL
for (i in 1:length(sequences)) {
  gc_results[i] = gc_content(sequences[i])
}
gc_results
```

This works, but has several problems:

1. **Verbose**: Lots of boilerplate code
2. **Error-prone**: Easy to make off-by-one errors
3. **Pollutes environment**: The loop variable `i` persists after the loop
4. **Not R-like**: R is designed for vectorized operations

### Functional Programming with lapply

The **functional programming** approach treats iteration as applying a function across elements:

```{r}
#| label: lapply-example

# Much cleaner!
gc_results = lapply(sequences, gc_content)
gc_results
```

The result is a list. To get a vector instead:

```{r}
#| label: sapply-example

gc_results = sapply(sequences, gc_content)
gc_results
```

To combine results into a data frame, use our detailed function with `bind_rows()`:

```{r}
#| label: lapply-bind

lapply(sequences, gc_content_detailed) %>%
  bind_rows()
```

### Using purrr for Iteration

The **purrr** package provides a consistent and powerful set of mapping functions:

```{r}
#| label: purrr-example

# map() returns a list (like lapply)
map(sequences, gc_content)

# map_dbl() returns a numeric vector
map_dbl(sequences, gc_content)

# map_df() returns a data frame
map_df(sequences, gc_content_detailed)
```

### Creating and Reusing Named Functions

For complex analyses, separate the function definition from iteration:

```{r}
#| label: named-function

# Define a function for processing protein sequences
analyze_protein = function(sequence) {
  seq_upper = toupper(sequence)
  length = nchar(seq_upper)

  # Count hydrophobic residues (simplified)
  hydrophobic = str_count(seq_upper, "[AILMFVPW]")

  # Count charged residues
  charged = str_count(seq_upper, "[DEKRH]")

  tibble(
    sequence = sequence,
    length = length,
    hydrophobic_pct = round(hydrophobic / length * 100, 1),
    charged_pct = round(charged / length * 100, 1)
  )
}

# Some sample protein sequences
proteins = c(
  "MKTAYIAKQRQISFVKSHFSRQLEERLGLIEVQAPILSRVGDGTQDNLSGAEKAVQVKVKALPDAQFEVVHSLAKWKRQQIAAALEHHHHHH",
  "MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSH",
  "GLSDGEWQQVLNVWGKVEADIAGHGQEVLIRLFTGHPETLEKFDKFKHLKTEAEMKASEDLKKHGTVVLTALGGILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISDAIIHVLHSKHPGDFGADAQGAMTKALELFRNDIAAKYKELGFQG"
)

# Apply to all proteins
map_df(proteins, analyze_protein)
```

## Iterating Over Multiple Inputs {#sec-multiple-inputs}

Sometimes you need to iterate over multiple inputs simultaneously.

### Using pmap for Multiple Arguments

```{r}
#| label: pmap-example

# Simulate growth curves with different parameters
simulate_growth = function(time, k, n0, carrying_capacity) {
  # Logistic growth model
  n = carrying_capacity / (1 + ((carrying_capacity - n0) / n0) * exp(-k * time))

  tibble(
    time = time,
    k = k,
    n0 = n0,
    K = carrying_capacity,
    population = round(n, 0)
  )
}

# Parameters for different bacterial strains
params = tibble(
  k = c(0.5, 0.8, 0.3),              # Growth rates
  n0 = c(100, 50, 200),              # Initial populations
  carrying_capacity = c(10000, 15000, 8000)  # Carrying capacities
)

# Run simulations for each strain at time = 10
pmap_df(params, ~simulate_growth(time = 10, k = ..1, n0 = ..2, carrying_capacity = ..3))
```

### Using a Data Frame of Inputs

A cleaner approach for complex cases is to pass a data frame of input combinations:

```{r}
#| label: df-inputs

# Create all parameter combinations
simulation_params = expand.grid(
  time = seq(0, 20, by = 2),
  strain = c("wild_type", "mutant_A", "mutant_B")
) %>%
  as_tibble() %>%
  mutate(
    k = case_when(
      strain == "wild_type" ~ 0.5,
      strain == "mutant_A" ~ 0.8,
      strain == "mutant_B" ~ 0.3
    ),
    n0 = 100,
    carrying_capacity = 10000
  )

# Function that takes a row of parameters
run_simulation = function(row_data) {
  simulate_growth(
    time = row_data$time,
    k = row_data$k,
    n0 = row_data$n0,
    carrying_capacity = row_data$carrying_capacity
  ) %>%
    mutate(strain = row_data$strain)
}

# Run all simulations
results = map_df(1:nrow(simulation_params), function(i) {
  run_simulation(simulation_params[i, ])
})

# Plot the results
ggplot(results, aes(x = time, y = population, color = strain)) +
  geom_line(linewidth = 1) +
  geom_point() +
  labs(
    title = "Bacterial Growth Curves",
    x = "Time (hours)",
    y = "Population Size",
    color = "Strain"
  ) +
  scale_y_continuous(labels = scales::comma)
```

## Best Practices for Writing Functions {#sec-function-best-practices}

### 1. Use Descriptive Names

```{r}
#| label: naming-examples
#| eval: false

# Good names
calculate_gc_content()
normalize_expression()
fit_growth_curve()

# Bad names
func1()
do_stuff()
f()
```

### 2. Document Your Functions

Add comments explaining what the function does, its arguments, and return value:

```{r}
#| label: documented-function

# Calculate the melting temperature of a DNA primer
#
# Uses the Wallace rule for short oligonucleotides (<14 bp)
# or the nearest-neighbor method for longer sequences
#
# Arguments:
#   sequence: DNA sequence (string of A, T, G, C)
#   method: "wallace" or "nearest_neighbor"
#
# Returns:
#   Melting temperature in degrees Celsius

calculate_tm = function(sequence, method = "wallace") {
  seq_upper = toupper(sequence)
  length = nchar(seq_upper)

  a_count = str_count(seq_upper, "A")
  t_count = str_count(seq_upper, "T")
  g_count = str_count(seq_upper, "G")
  c_count = str_count(seq_upper, "C")

  if (method == "wallace" || length < 14) {
    # Wallace rule: Tm = 2(A+T) + 4(G+C)
    tm = 2 * (a_count + t_count) + 4 * (g_count + c_count)
  } else {
    # Simplified nearest-neighbor approximation
    tm = 64.9 + 41 * (g_count + c_count - 16.4) / length
  }

  return(tm)
}

calculate_tm("ATGCGATCGATCG")
```

### 3. Validate Inputs

Check that inputs are valid before processing:
```{r}
#| label: input-validation

gc_content_safe = function(sequence) {
  # Check input type
  if (!is.character(sequence)) {
    stop("Sequence must be a character string")
  }

  # Check for valid DNA characters
  seq_upper = toupper(sequence)
  invalid_chars = str_remove_all(seq_upper, "[ATGCN]")
  if (nchar(invalid_chars) > 0) {
    warning(paste("Invalid characters removed:", invalid_chars))
  }

  gc_count = str_count(seq_upper, "[GC]")
  total_bases = str_count(seq_upper, "[ATGC]")

  if (total_bases == 0) {
    stop("No valid DNA bases found in sequence")
  }

  return(gc_count / total_bases)
}

gc_content_safe("ATGCGATCG")     # Works fine
gc_content_safe("ATGCXYZGATCG")  # Warning about invalid characters
```

### 4. Keep Functions Focused

Each function should do one thing well. Break complex operations into smaller functions:

```{r}
#| label: focused-functions

# Instead of one giant function, break it up:

# Step 1: Clean the sequence
clean_sequence = function(seq) {
  seq %>%
    toupper() %>%
    str_remove_all("[^ATGC]")
}

# Step 2: Calculate base composition
base_composition = function(seq) {
  tibble(
    A = str_count(seq, "A"),
    T = str_count(seq, "T"),
    G = str_count(seq, "G"),
    C = str_count(seq, "C")
  )
}

# Step 3: Derive statistics
sequence_stats = function(composition) {
  total = sum(composition)
  composition %>%
    mutate(
      total = total,
      gc_content = (G + C) / total,
      at_content = (A + T) / total
    )
}

# Combine them in a pipeline
"atgcGATCgatcgNNNN" %>%
  clean_sequence() %>%
  base_composition() %>%
  sequence_stats()
```

## Summary {#sec-functions-summary}

Writing functions is a fundamental programming skill that will dramatically improve your data analysis workflows:

- **Basic syntax**: `function_name = function(args) { body; return(value) }`
- **Return values**: Use explicit `return()` statements; return lists or data frames for multiple values
- **Default arguments**: Provide sensible defaults for commonly-used parameter values
- **Lexical scoping**: Functions operate in their own environment, keeping your global environment clean
- **Control flow**: Use `if/else` and `case_when()` to handle different conditions
- **Functional programming**: Prefer `lapply()`/`map()` over for loops for iteration
- **Multiple inputs**: Use `pmap()` or data frame inputs for complex parameter combinations

The next chapter will show you how to debug functions when things go wrong, catch user errors gracefully, and cache results for expensive computations.

## Additional Reading {.unnumbered}

To deepen your understanding of functions and functional programming in R:

- **[R for Data Science: Functions](https://r4ds.hadley.nz/functions)** — Excellent introduction to writing functions
- **[Advanced R: Functions](https://adv-r.hadley.nz/functions.html)** by Hadley Wickham — Deep dive into function mechanics
- **[purrr Documentation](https://purrr.tidyverse.org/)** — Complete guide to functional programming with purrr
- **[R for Data Science: Iteration](https://r4ds.hadley.nz/iteration)** — More on map functions and iteration

For advanced function development:

- **[Advanced R: Functional Programming](https://adv-r.hadley.nz/fp.html)** — Closures, function factories, and more
- **[R Packages](https://r-pkgs.org/)** by Wickham and Bryan — When you're ready to package your functions

## Exercises {.unnumbered}

::: {.callout-tip title="Practice Exercises"}
**Exercise 1: Basic Function**

Write a function called `count_codons()` that takes a DNA sequence and returns the number of complete codons (groups of 3 nucleotides). For example, "ATGCGA" has 2 complete codons.

**Exercise 2: Function with Multiple Returns**

Write a function `analyze_sequence()` that takes a DNA sequence and returns a data frame with:
- The sequence length
- GC content
- Number of each base (A, T, G, C)
- Whether it starts with a start codon (ATG)
- Whether it ends with a stop codon (TAA, TAG, or TGA)

**Exercise 3: Control Flow**

Write a function `translate_codon()` that takes a three-letter codon and returns the corresponding amino acid (use a simplified table with just 5-10 codons). Include error handling for invalid inputs.

**Exercise 4: Iteration**

You have a vector of 10 DNA sequences. Use `map_df()` to apply your `analyze_sequence()` function from Exercise 2 to all of them and combine the results into a single data frame.

**Exercise 5: Multiple Inputs**

Write a function `dilution_series()` that takes an initial concentration and dilution factor, then returns a data frame showing the concentration at each step for a specified number of dilutions. Use `pmap()` to apply this to multiple starting conditions.

**Exercise 6: Refactoring**

Take the following for loop and rewrite it using functional programming:

```r
results = c()
for (i in 1:length(sequences)) {
  gc = gc_content(sequences[i])
  if (gc > 0.5) {
    results = c(results, "high")
  } else {
    results = c(results, "low")
  }
}
```
:::
